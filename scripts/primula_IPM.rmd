---
title: "primula_IPM"
author: "JL"
date: "3/2/2023"
output: html_document
---
to do before publication:
-clean up stuff i dont need (comented out things)
update file pathways
rerun bootstrapping
make sure discrete thinsg are up to date
edit appendix fig with pot experiment lines

-
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(AICcmodavg)
library(lme4)
library(popbio)
library(patchwork) #for putting plots into one
theme_set(theme_classic()) #for ggplot
library(wesanderson) # for colors
Z <- wes_palettes$Zissou1

```

```{r}
# Read in data ------------------------------------------------------------------------

### read in all years of Primula data and weather data from the Cowichan
# Add in climate data:
climate_scale <- read.csv("C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/data_for_publication/CGOP_climatevalues_scaled.csv")

# Add in demography data:
primula <- read.csv("C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/data_for_publication/Primula_Demography_Data_2016to2023.csv")

## Join climate data to demography data by year
primula <- left_join(primula, climate_scale, by = "year") %>%
  mutate(pflower = as.factor(pflower),
         pflowerT1 = as.factor(pflowerT1),
         psurvivalT1 = as.factor(psurvivalT1))
remove(climate_scale)

#these are for the new plants - we weren't consistent with what we called a new adult
new.plants <- primula %>%   
  mutate(leaves = if_else(year == 2022, no.smleaf + no.bigleaf, leaves)) %>% 
  filter(year == YrTag) %>% ##need to filter cases where year tagged == year (so newly tagged that year)
  filter(pflower == 0) %>% ## actual new plants definitely can't flower in the first year
  filter(leaves < 3) %>% ## can't have more than 3 leaves
  filter(!is.na(log.ros.area))
```

I thought a lot here about parametric versus non parametric bootstrapping - I'm going with parametric because it seems easier, and we are running models that we have confidence in. Also we won't have the convergence problem that we had with the townsendia bootstrapped data (some bootstrapped data samples lead to models that wouldnt converge). It is also easier to code!

## Bootstrapped IPM for Primula data
```{r bootstrapping model coefficients}
#can use this code even if not bootstrapping - just use fixed effects from original models

# set number of bootstrap samples:
boot = 1000

#set seed so we have the same parameters each time
set.seed(12345)

###
fm.gs.av.temp.cor.int1 <- glmer(pflowerT1 ~ log.ros.area*pflower + spring.mean.temp + (1|plot) + (1|year), data = primula, family = "binomial")
#parametric bootstrap
#make matrix of random draws
pflower_samp = MASS::mvrnorm(n=boot, mu=fixef(fm.gs.av.temp.cor.int1), Sigma=vcov(fm.gs.av.temp.cor.int1))
#pflower_samp
#apply(pflower_samp,2,mean) #double check that the means are similar to fixef
#fixef(fm.gs.av.temp.cor.int1)

####
sm.gs.av.temp <- glmer(psurvivalT1 ~ log.ros.area + spring.mean.temp + (1|plot) + (1|year), data = primula, family = "binomial")
#parametric bootstrap
#make matrix of random draws
psurv_samp = MASS::mvrnorm(n=boot, mu=fixef(sm.gs.av.temp), Sigma=vcov(sm.gs.av.temp))
#psurv_samp
#apply(psurv_samp,2,mean) #double check that the means are similar to fixef
#fixef(sm.gs.av.temp)
###

gm.summer.av.temp.cor.trt.int6 <- lmer(log.ros.areaT1 ~ log.ros.area*pflower + trt*summer.mean.temp + (1|plot) + (1|year), data = primula, REML = F)
#parametric bootstrap
#make matrix of random draws
grow_samp = MASS::mvrnorm(n=boot, mu=fixef(gm.summer.av.temp.cor.trt.int6), Sigma=vcov(gm.summer.av.temp.cor.trt.int6))
#grow_samp
#apply(grow_samp,2,mean) #double check that the means are similar to fixef
#fixef(gm.summer.av.temp.cor.trt.int6)

#variance for growth:
growth_var <- as.data.frame(VarCorr(gm.summer.av.temp.cor.trt.int6)) #assumes same variance across all
###

noflowers.winter.av.temp <- glmer(flow.sumT1 ~ log.ros.area + winter.mean.temp + (1|plot) + (1|year), data = subset(primula, flow.sumT1 > 0), family = "poisson")
#parametric bootstrap
#make matrix of random draws
noflowers_samp = MASS::mvrnorm(n=boot, mu=fixef(noflowers.winter.av.temp), Sigma=vcov(noflowers.winter.av.temp))
#noflowers_samp
#apply(noflowers_samp,2,mean) #double check that the means are similar to fixef
#fixef(noflowers.winter.av.temp)
```
Then the other miscellany we'll need (size independent parameters):
```{r}
prob.seed.germ <- .022 #this is from the seed addition data - average seed has 0.022 chance of germination
prob.seedling.to.1leaf <- .03 #this is estimated from seed miniplots

#use this for the pest test
#define range of p_est to test
#pest_sample<-seq(0.001, 0.2, 0.001)

#if a one leaf survives it will either stay as a one leaf or go to adult. BUT they can die. So. One leafs can either die, stay the same, or grow
prob.1leaf.to.1leaf <- .41*.42 # p that it survives and probability it doesn't become a 2 leaf
prob.1leaf.to.2leaf <- .41*.58 #p that it survives and probability that it becomes an adult

#eventually this might change if we want treatment specific size of new recruits
new_sd <- sd(new.plants$log.ros.area)
new_mean <- mean(new.plants$log.ros.area)
hist(new.plants$log.ros.area)

#Define the min and max size, which are the integration bounds of the IPM.
minRealsize <- min(primula$log.ros.area, na.rm=T) 
maxRealsize <- 1.1* max(primula$log.ros.area,na.rm=T)

#now add a new min & max size to keep the plants in for eviction - floor ceiling approach
min.size <-minRealsize-1 #lower
max.size <-maxRealsize+1.5 #upper

```

## Collect model parameters into a vector

This is a little tricky! There are a lot of variables in the models, so be careful here with the equations for the mixed models

These are for the ipm WITH the bootstrap
```{r parameters boot, echo=FALSE}
#this is for range of climates
rows <- expand.grid(summer.mean.temp = seq(-2, 2, by = .5), spring.mean.temp = seq(-2, 2, by = .5),  winter.mean.temp = seq(-2, 2, by = .5), reproduction = c("veg","flowered"), trt = c("control", "drought", "irrigated"))

#set up an empty parameter df
params=data.frame(
	growth.int = c(NA),
	growth.slope  = NA,
	growth.sd=NA,
	surv.int=NA,
	surv.slope=NA,
	pflow.int = NA,
	pflow.slope = NA,
	no.flow.int=NA,
	no.flow.slope=NA,
	recruit.size.mean=NA,
	recruit.size.sd=NA,
	prob.seed.germ = NA
)
params <- bind_cols(params, rows)
```

Stick all the bootstrapped parameters in. And use coefficients from the parametric bootstrap:
```{r bootstrapped parameters}
###
summer.mean.temp = expand_grid(summer.mean.temp = seq(-2, 2, by = 1))
#growth intercept:
# data frame to store the results
growth.int <- data.frame(
  growth.int = numeric(6 * boot * nrow(summer.mean.temp)),
  summer.mean.temp = numeric(6 * boot * nrow(summer.mean.temp)),
  reproduction = character(6 * boot * nrow(summer.mean.temp)),
  trt = character(6 * boot * nrow(summer.mean.temp)),
  boot.group = numeric(6 * boot * nrow(summer.mean.temp))
)

# Counter to keep track of the row index
row_index <- 1

# Outer loop - for bootstrapped coefficients
for (j in 1:boot) {
  # Inner loop - for temperature values
  for (i in 1:nrow(summer.mean.temp)) {
    # Fill for veg control
    growth.int[row_index, "growth.int"] <- grow_samp[j,1] + grow_samp[j,6]*summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "summer.mean.temp"] <- summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "reproduction"] <- "veg"
    growth.int[row_index, "trt"] <- "control"
    growth.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index

    
    # Increment the row index
    row_index <- row_index + 1
    
    # Fill for flowered control
    growth.int[row_index, "growth.int"] <- grow_samp[j,1] + grow_samp[j,6]*summer.mean.temp$summer.mean.temp[i] + grow_samp[j,3]
    growth.int[row_index, "summer.mean.temp"] <- summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "reproduction"] <- "flowered"
    growth.int[row_index, "trt"] <- "control"
        growth.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index

    
    # Increment the row index
    row_index <- row_index + 1
    
    # Fill for veg irrigated
    growth.int[row_index, "growth.int"] <- grow_samp[j,1] + grow_samp[j,5] + grow_samp[j,6]*summer.mean.temp$summer.mean.temp[i] + grow_samp[j,9]*summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "summer.mean.temp"] <- summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "reproduction"] <- "veg"
    growth.int[row_index, "trt"] <- "irrigated"
        growth.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index

    
    # Increment the row index
    row_index <- row_index + 1
    
    # Fill for flow irrigated
    growth.int[row_index, "growth.int"] <- grow_samp[j,1] + grow_samp[j,3] + grow_samp[j,5] + grow_samp[j,6]*summer.mean.temp$summer.mean.temp[i] + grow_samp[j,9]*summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "summer.mean.temp"] <- summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "reproduction"] <- "flowered"
    growth.int[row_index, "trt"] <- "irrigated"
        growth.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index

    
    # Increment the row index
    row_index <- row_index + 1
        
    # Fill for veg drought
    growth.int[row_index, "growth.int"] <- grow_samp[j,1] + grow_samp[j,4] + grow_samp[j,8]*summer.mean.temp$summer.mean.temp[i] + grow_samp[j,6]*summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "summer.mean.temp"] <- summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "reproduction"] <- "veg"
    growth.int[row_index, "trt"] <- "drought"
        growth.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index

    
    # Increment the row index
    row_index <- row_index + 1
    
    # Fill for flow drought
    growth.int[row_index, "growth.int"] <- grow_samp[j,1] + 
      grow_samp[j,3] +
      grow_samp[j,4] + 
      grow_samp[j,8]*summer.mean.temp$summer.mean.temp[i] + 
      grow_samp[j,6]*summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "summer.mean.temp"] <- summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "reproduction"] <- "flowered"
    growth.int[row_index, "trt"] <- "drought"
        growth.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index

    
    # Increment the row index
    row_index <- row_index + 1
  }
}

#growth slope
growth.slope <- data.frame(
  growth.slope = c(grow_samp[, 2] + grow_samp[, 7], grow_samp[, 2]),
  reproduction = c(rep("flowered", nrow(grow_samp)), rep("veg", nrow(grow_samp))),
  boot.group = c(rep(1:nrow(grow_samp)), rep(1:nrow(grow_samp)))
)

growth <- left_join(growth.int, growth.slope)

##################################
#survival boot
spring.mean.temp = expand_grid(spring.mean.temp = seq(-2, 2, by = 1))

surv.slope <- data.frame(surv.slope = psurv_samp[, 2], boot.group = seq(1, boot, by = 1))

surv.int <- data.frame()
row_index <- 1

# Outer loop - for bootstrapped coefficients
for (j in 1:boot) {
  # Inner loop - for temperature values
  for (i in 1:nrow(spring.mean.temp)) {
    # Fill for veg control
    surv.int[row_index, "surv.int"] <-  psurv_samp[j, 1] + psurv_samp[j, 3] * spring.mean.temp$spring.mean.temp[i]
    surv.int[row_index, "spring.mean.temp"] <- spring.mean.temp$spring.mean.temp[i]
    surv.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index
   # Increment the row index
    row_index <- row_index + 1
}}

surv <-left_join(surv.int, surv.slope)

###
#####################
#slopes:

pflow.slope <- rbind(
  data.frame(pflow.slope = pflower_samp[,2], reproduction = "veg", boot.group = rep(1:nrow(grow_samp))),
  data.frame(pflow.slope = pflower_samp[,2] + pflower_samp[,5], reproduction = "flowered", boot.group = rep(1:nrow(grow_samp)))
  
)
#intercepts:
pflow.int <- data.frame()

row_index <- 1

# Outer loop - for bootstrapped coefficients
for (j in 1:boot) {
  # Inner loop - for temperature values
  for (i in 1:nrow(spring.mean.temp)) {
    # Fill for veg 
    pflow.int[row_index, "pflow.int"] <-  pflower_samp[j, 1] + pflower_samp[j, 4] * spring.mean.temp$spring.mean.temp[i]
    pflow.int[row_index, "spring.mean.temp"] <- spring.mean.temp$spring.mean.temp[i]
    pflow.int[row_index, "reproduction"] <- "veg"
    pflow.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index
   # Increment the row index
    row_index <- row_index + 1
    
    # Fill for flowered
    pflow.int[row_index, "pflow.int"] <-  pflower_samp[j, 1] + pflower_samp[j, 4] * spring.mean.temp$spring.mean.temp[i] + pflower_samp[j, 3]
    pflow.int[row_index, "spring.mean.temp"] <- spring.mean.temp$spring.mean.temp[i]
    pflow.int[row_index, "reproduction"] <- "flowered"
    pflow.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index
   # Increment the row index
    row_index <- row_index + 1
  }
  }

pflow <- left_join(pflow.int, pflow.slope)
###############################################################
#boot
winter.mean.temp = expand_grid(winter.mean.temp = seq(-2, 2, by = 1))

no.flow.slope <- data.frame(no.flow.slope = noflowers_samp[, 2], boot.group = seq(1, boot, by = 1))

no.flow.int <- data.frame()
row_index <- 1

# Outer loop - for bootstrapped coefficients
for (j in 1:boot) {
  # Inner loop - for temperature values
  for (i in 1:nrow(winter.mean.temp)) {
    no.flow.int[row_index, "no.flow.int"] <-  noflowers_samp[j, 1] + noflowers_samp[j, 3] * winter.mean.temp$winter.mean.temp[i]
    no.flow.int[row_index, "winter.mean.temp"] <- winter.mean.temp$winter.mean.temp[i]
    no.flow.int[row_index, "boot.group"] <- j  # Add the bootstrapped group indexj
   # Increment the row index
    row_index <- row_index + 1
}}

no.flow <- left_join(no.flow.slope, no.flow.int)

##stick these into one df
boot.params <- left_join(surv, no.flow)
boot.params <- left_join(boot.params, growth)
boot.params <- left_join(boot.params, pflow)

#Ok great, this looks like it works!
#####

#currently, seeds per flower is not size dependent, but is treatment dependent
#flowers in drought plots make 6 seeds, control make 11, irrigated make 13
boot.params$seeds[boot.params$trt == "irrigated"] <- 13
boot.params$seeds[boot.params$trt == "drought"] <- 6
boot.params$seeds[boot.params$trt == "control"] <- 11

boot.params$prob.seed.germ <- prob.seed.germ
boot.params$recruit.size.mean <- new_mean # mean new >1 leaf plant size
boot.params$recruit.size.sd<- new_sd # sd of new >1 leaf plant size
boot.params$growth.sd <- growth_var[growth_var$grp=="Residual","sdcor"] # growth sd of residuals
```

# Build the model!

### Step 1. Build vital rate functions (components of the kernel)
```{r with bootstrap functions}
###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
###         Load functions
###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#SURVIVAL AT SIZE X
s.x=function(x,boot.params) {
	u=exp(boot.params$surv.int+boot.params$surv.slope*x)
	return(u/(1+u))
}

#how to test this: 
### run function for a plant of size 1 and for the first row of parameters
#s.x(x = 1, boot.params = boot.params[1,])
### run function for a plant of size 1 but for all rows of parameters (so get a list )
#s.x(x = 1, boot.params = boot.params)
#ok this works and seems to work for all rows of boot.params. great.

#GROWTH FROM SIZE X TO Y; 
  ## returns a *probability density distribution* for each x value
g.yx<-function(y,x,boot.params){
    # eviction here...
  xb=pmin(pmax(x,minRealsize),maxRealsize) #Transforms all values below/above limits in min/max size (floor & ceiling)
  growth_to_newsize <-boot.params$growth.int + boot.params$growth.slope*xb
  growth_sd <- boot.params$growth.sd
  return(dnorm(y,mean=growth_to_newsize,sd=growth_sd))
  #dnorm(y,mean=boot.params$growth.int + boot.params$growth.slope*x,sd=boot.params$growth.sd)

}
#to test this:
#g.yx(y = 1, x = 1, boot.params = boot.params[1,])

#Tom Miller's combined s and g kernel
P <- function(y, x, boot.params){
  s.x(x, boot.params)*g.yx(y, x, boot.params)
}

#PROBABILITY OF FLOWERING OF SIZE X individuals
pf.x <-function(x,boot.params){
	u<-exp(boot.params$pflow.int+boot.params$pflow.slope*x)
	return(u/(1+u))
}
#testing this for a plant of size 5
#pf.x(x = 8,boot.params = boot.params)

f.yx=function(x,boot.params) { 		
	#return(pf.x(x,boot.params)*exp(boot.params$no.flow.int+boot.params$no.flow.slope*x)* exp(boot.params$no.seeds.int+boot.params$no.seeds.slope*x) *
  return(pf.x(x,boot.params)*exp(boot.params$no.flow.int+boot.params$no.flow.slope*x)* boot.params$seeds * boot.params$prob.seed.germ)
}
##so this should be outputting the number of seedlings made? Yes
#f.yx(x = 5,boot.params = boot.params)

##do big plants make a million flowers?
#exp(boot.params$no.flow.int+boot.params$no.flow.slope*8) 
## no they make a reasonable amount


#SIZE DISTRIBUTION OF RECRUITS - so the ones going from the 1 leaf stage into the continuous stage. I'm not sure that this is doing what I want it to - 
recruit.size<-function(y,boot.params){
    ## returns a *probability density distribution*
  dnorm(y,mean=boot.params$recruit.size.mean,sd=boot.params$recruit.size.sd)
}
```

```{r get bootstrapped lambdas)}
params_list <-  filter(boot.params) %>% split(., seq(nrow(.))) #this splits up params into X rows, which I can feed into the function below

#params_in <- params_list[1] #to test it!
# BIGMATRIX ---------------------------------------------------------------
#building off of code from Tom Miller:
mat.size = 100 #dimensions of continuous matrix
bigmatrix<-function(params_list, mat.size)
  {
  n<-mat.size
  L<-min.size
  U<-max.size
  #these are the upper and lower integration limits
  h<-(U-L)/n                   #Bin size
  b<-L+c(0:n)*h;               #Lower boundaries of bins 
  y<-0.5*(b[1:n]+b[2:(n+1)]);  #Bins' midpoints
  #these are the boundary points (b) and mesh points (y)

  # Fertility matrix
  Fmat<-matrix(0,(n+2),(n+2))
  
  # top row: # seedlings produced by each size class:
  Fmat[1,3:(n+2)]<-f.yx(y,params_list) #This is a y because it is the fecundity kernel for plants that have already grown/survived, I think? It's what Tom has
  
  # Growth/survival transition matrix
  Tmat<-matrix(0,(n+2),(n+2))
  
  # probability seedling becomes a 1 leaf plant
  Tmat[2,1]<- prob.seedling.to.1leaf
  
   # probability 1 leaf plant stays as a 1 leaf plant
  Tmat[2,2]<- prob.1leaf.to.1leaf
  
  # Graduation from 1 leaf to cts size = prob 1 leaf becomes a 2 leaf * size dist of new 2 leafers
  Tmat[3:(n+2),2]<- prob.1leaf.to.2leaf *recruit.size(y,params_list) * h
  
  # Growth/survival transitions among cts sizes
  Tmat[3:(n+2),3:(n+2)]<- t(outer(y,y,P,boot.params=params_list)) * h 
  
  # Put it all together
  IPMmat<-Fmat+Tmat     #Full Kernel is simply a summation of fertility and transition matrix
  out_matrix <- list(IPMmat=IPMmat,Fmat=Fmat,Tmat=Tmat,meshpts=y)
  
  out_lamb <- data.frame(lambda = lambda(IPMmat), summer.temp = params_list$summer.mean.temp,  gs.temp = params_list$spring.mean.temp, winter.temp = params_list$winter.mean.temp, reproduction = params_list$reproduction, trt = params_list$trt, boot.group = params_list$boot.group)
 # return(out_matrix) #can check this to have a list of all of the matrices listed above
  return(out_lamb) #for now, I just want lambdas
 # return(list(out_matrix = out_matrix, out_lamb = out_lamb))

}

#what I want returned is lambdas
lamb_lists <- lapply(X = params_list, FUN = bigmatrix, mat.size = mat.size) #for each row of params_list, run the big matrix function!
#great~! now make it a df
boot_lambda <- do.call(rbind, lamb_lists)
write.csv(boot_lambda, "C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula//tables/primula.bootstrap.climate.lambdas.2024.08.24.csv", row.names = F)
```

```{r bootstrap figures}
quant <- boot_lambda %>% 
  group_by(summer.temp, gs.temp, winter.temp, reproduction, trt) %>% 
  summarize(mean.lambda = mean(lambda),
            upper.quant = quantile(lambda, probs = 0.975),
            lower.quant = quantile(lambda, probs = 0.025))

(q.gs <- quant %>% 
  filter(summer.temp == 0 & winter.temp == 0) %>% 
  ggplot(aes(x = gs.temp, y = mean.lambda, color = trt, linetype = reproduction))+
  geom_line(linewidth = 1.6)+
  geom_ribbon(aes(x = gs.temp, ymin = lower.quant, ymax = upper.quant, fill = trt), linewidth = .75, alpha = 0.1)+
  facet_wrap(~trt)+
  scale_color_manual(values = c("#5f9034", "#e81014", "#2892c7"), name = "")+
  scale_fill_manual(values = c("#5f9034", "#e81014", "#2892c7"), name = "")+
  labs(y = expression(paste("\u03BB")), x = "Spring Temperature")+
  coord_cartesian(ylim = c(.77, 1.02))+ 
  geom_hline(yintercept = 1, color= "black", linewidth = .2)+
  scale_linetype_manual(values=c("dotted", "solid"), labels = c("vegetative", "flowered"), name = "") +  
  theme(strip.background = element_blank(), strip.text.x = element_blank(), axis.line = element_line(colour = 'black', linewidth = 1.1), 
        text = element_text(size = 20))) #remove facet wrap labels


(q.sum <- quant %>% 
  filter(gs.temp == 0 & winter.temp == 0) %>% 
  ggplot(aes(x = summer.temp, y = mean.lambda, color = trt, linetype = reproduction))+
  geom_line(linewidth = 1.6)+
  geom_ribbon(aes(x = summer.temp, ymin = lower.quant, ymax = upper.quant, fill = trt), linewidth = .75, alpha = 0.1)+
  facet_wrap(~trt)+
  scale_y_continuous(limits=c(.77,1.02))+ 
  scale_color_manual(values = c("#5f9034", "#e81014", "#2892c7"), name = "")+
  scale_fill_manual(values = c("#5f9034", "#e81014", "#2892c7"), name = "")+
  labs(y = expression(paste("\u03BB")), x = "Summer Temperature")+
  geom_hline(yintercept = 1, color= "black", linewidth = .2)+
  scale_linetype_manual(values=c("dotted", "solid"), labels = c("vegetative", "flowered"), name = "") +  
  theme(strip.background = element_blank(), strip.text.x = element_blank(), axis.line = element_line(colour = 'black', linewidth = 1.1), 
        text = element_text(size = 20))) #remove facet wrap labels


(q.win <- quant %>% 
  filter(summer.temp == 0 & gs.temp == 0) %>% 
  ggplot(aes(x = winter.temp, y = mean.lambda, color = trt, linetype = reproduction))+
  geom_line(linewidth = 1.6)+
  scale_y_continuous(limits=c(.77,1.02))+ 
  geom_ribbon(aes(x = winter.temp, ymin = lower.quant, ymax = upper.quant, fill = trt), linewidth = .75, alpha = 0.1)+
  facet_wrap(~trt)+
  scale_color_manual(values = c("#5f9034", "#e81014", "#2892c7"), name = "")+
  scale_fill_manual(values = c("#5f9034", "#e81014", "#2892c7"), name = "")+
  labs(y = expression(paste("\u03BB")), x = "Winter Temperature")+
  scale_linetype_manual(values=c("dotted", "solid"), labels = c("vegetative", "flowered"), name = "") +  
  geom_hline(yintercept = 1, color= "black", linewidth = .2)+
  theme(strip.background = element_blank(), strip.text.x = element_blank(), axis.line = element_line(colour = 'black', linewidth = 1.1), 
        text = element_text(size = 20)))

#patch work package
(boot.ipm <- q.gs + q.sum +  q.win + plot_layout(guides = "collect", ncol = 1)+plot_annotation(tag_level = "A"))
ggsave(plot = boot.ipm, file = "C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/Figures/IPM/ipm bootstrap aug26.png", width = 10, height = 10, dpi = 300)


```

######
BELOW CODE IS FOR WITHOUT BOOT
These are for the ipm without the bootstrap
```{r parameters without boot, echo=FALSE}
#this is for range of climates
rows <- expand.grid(summer.mean.temp = seq(-2, 2, by = .5), spring.mean.temp = seq(-2, 2, by = .5),  winter.mean.temp = seq(-2, 2, by = .5), reproduction = c("veg","flowered"), trt = c("control", "drought", "irrigated"))

#set up an empty parameter df
params=data.frame(
	growth.int = c(NA),
	growth.slope  = NA,
	growth.sd=NA,
	surv.int=NA,
	surv.slope=NA,
	pflow.int = NA,
	pflow.slope = NA,
	no.flow.int=NA,
	no.flow.slope=NA,
	recruit.size.mean=NA,
	recruit.size.sd=NA,
	prob.seed.germ = NA
)
params <- bind_cols(params, rows)
```

```{r original parameters, echo=T}
#growth:
for (i in 1:nrow(params)) {
  if (params$reproduction[i] == "veg" && params$trt[i] == "control") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] + fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i]
  } else if (params$reproduction[i] == "flowered" && params$trt[i] == "control") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] + fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i] + fixef(gm.summer.av.temp.cor.trt.int6)[3]
  } else if (params$reproduction[i] == "veg" && params$trt[i] == "irrigated") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] + fixef(gm.summer.av.temp.cor.trt.int6)[5] + 
      fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i] +
      fixef(gm.summer.av.temp.cor.trt.int6)[9] * params$summer.mean.temp[i]
  } else if (params$reproduction[i] == "flowered" && params$trt[i] == "irrigated") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] +  fixef(gm.summer.av.temp.cor.trt.int6)[3] + fixef(gm.summer.av.temp.cor.trt.int6)[5] +
      fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i] +            fixef(gm.summer.av.temp.cor.trt.int6)[9] * params$summer.mean.temp[i]
  } else if (params$reproduction[i] == "veg" && params$trt[i] == "drought") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] +   fixef(gm.summer.av.temp.cor.trt.int6)[4] + 
      fixef(gm.summer.av.temp.cor.trt.int6)[8] * params$summer.mean.temp[i] + 
      fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i]
  } else if (params$reproduction[i] == "flowered" && params$trt[i] == "drought") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] + #intercept
      fixef(gm.summer.av.temp.cor.trt.int6)[3] + #pflower = 1 intercept
      fixef(gm.summer.av.temp.cor.trt.int6)[4] + #trt = drought int
      fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i] + fixef(gm.summer.av.temp.cor.trt.int6)[8] * params$summer.mean.temp[i]
  }
}

#slope for growth
params$growth.slope[params$reproduction == "veg"] <- fixef(gm.summer.av.temp.cor.trt.int6)[2]
params$growth.slope[params$reproduction == "flowered"]<- fixef(gm.summer.av.temp.cor.trt.int6)[2] + fixef(gm.summer.av.temp.cor.trt.int6)[7]

params$growth.sd <- growth_var[growth_var$grp=="Residual","sdcor"] # growth sd of residuals

###########################################################################################
#survival = sm.gs.av.temp
for (i in 1:nrow(params)) {
  params$surv.int[i] <- fixef(sm.gs.av.temp)[1] + fixef(sm.gs.av.temp)[3]*params$spring.mean.temp[i]
}

#slope
params$surv.slope <- fixef(sm.gs.av.temp)[2] # survival size t
###########################################################################################
#pflower
for (i in 1:nrow(params)) {
  if (params$reproduction[i] == "veg") {
    params$pflow.int[i] <- fixef(fm.gs.av.temp.cor.int1)[1] + fixef(fm.gs.av.temp.cor.int1)[4] * params$spring.mean.temp[i]
  } else if (params$reproduction[i] == "flowered") {
    params$pflow.int[i] <- fixef(fm.gs.av.temp.cor.int1)[1] + fixef(fm.gs.av.temp.cor.int1)[4] * params$spring.mean.temp[i] + fixef(fm.gs.av.temp.cor.int1)[3]
  }
}

#slopes:
params$pflow.slope[params$reproduction == "veg"] <- fixef(fm.gs.av.temp.cor.int1)[2]
params$pflow.slope[params$reproduction == "flowered"]<- fixef(fm.gs.av.temp.cor.int1)[2] + fixef(fm.gs.av.temp.cor.int1)[5]
##############################################################################################
# no.flowers
for (i in 1:nrow(params)) {
    params$no.flow.int[i] <- fixef(noflowers.winter.av.temp)[1] + fixef(noflowers.winter.av.temp)[3]*params$winter.mean.temp[i]
}

params$no.flow.slope <- fixef(noflowers.winter.av.temp)[2] # flower number production size t
#####

#currently, seeds per flower is not size dependent, but is treatment dependent
#flowers in drought plots make 6 seeds, control make 11, irrigated make 13
params$seeds[params$trt == "irrigated"] <- 13
params$seeds[params$trt == "drought"] <- 6
params$seeds[params$trt == "control"] <- 11

params$prob.seed.germ <- prob.seed.germ
params$recruit.size.mean <- new_mean # mean new >1 leaf plant size
params$recruit.size.sd<- new_sd # sd of new >1 leaf plant size
```

```{r without bootstrap functions}
###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
###         Load functions
###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#SURVIVAL AT SIZE X
s.x=function(x,params) {
	u=exp(params$surv.int+params$surv.slope*x)
	return(u/(1+u))
}

#GROWTH FROM SIZE X TO Y; 
  ## returns a *probability density distribution* for each x value
g.yx<-function(y,x,params){
    # eviction here...
  xb=pmin(pmax(x,minRealsize),maxRealsize) #Transforms all values below/above limits in min/max size (floor & ceiling)
  growth_to_newsize <-params$growth.int + params$growth.slope*xb
  growth_sd <- params$growth.sd
  return(dnorm(y,mean=growth_to_newsize,sd=growth_sd))

}


#Tom Miller's combined s and g kernel
P <- function(y, x, params){
  s.x(x, params)*g.yx(y, x, params)
}

#PROBABILITY OF FLOWERING OF SIZE X individuals
pf.x <-function(x,params){
	u<-exp(params$pflow.int+params$pflow.slope*x)
	return(u/(1+u))
}

f.yx=function(x,params) { 		
  return(pf.x(x,params)*exp(params$no.flow.int+params$no.flow.slope*x)* params$seeds * params$prob.seed.germ)
}

#SIZE DISTRIBUTION OF RECRUITS - so the ones going from the 1 leaf stage into the continuous stage. I'm not sure that this is doing what I want it to - 
recruit.size<-function(y,params){
    ## returns a *probability density distribution*
  dnorm(y,mean=params$recruit.size.mean,sd=params$recruit.size.sd)
}
```

```{r get lambdas (no bootstrap no ltre)}
params_list <-  filter(params) %>% split(., seq(nrow(.))) #this splits up params into X rows, which I can feed into the function below


#params_in <- params_list[1] #to test it!
# BIGMATRIX ---------------------------------------------------------------
#building off of code from Tom Miller:
mat.size = 100 #dimensions of continuous matrix
bigmatrix<-function(params_list, mat.size)
  {
  n<-mat.size
  L<-min.size
  U<-max.size
  #these are the upper and lower integration limits
  h<-(U-L)/n                   #Bin size
  b<-L+c(0:n)*h;               #Lower boundaries of bins 
  y<-0.5*(b[1:n]+b[2:(n+1)]);  #Bins' midpoints
  #these are the boundary points (b) and mesh points (y)

  # Fertility matrix
  Fmat<-matrix(0,(n+2),(n+2))
  
  # top row: # seedlings produced by each size class:
  Fmat[1,3:(n+2)]<-f.yx(y,params_list) #This is a y because it is the fecundity kernel for plants that have already grown/survived, I think? It's what Tom has
  
  # Growth/survival transition matrix
  Tmat<-matrix(0,(n+2),(n+2))
  
  # probability seedling becomes a 1 leaf plant
  Tmat[2,1]<- prob.seedling.to.1leaf
  
   # probability 1 leaf plant stays as a 1 leaf plant
  Tmat[2,2]<- prob.1leaf.to.1leaf
  
  # Graduation from 1 leaf to cts size = prob 1 leaf becomes a 2 leaf * size dist of new 2 leafers
  Tmat[3:(n+2),2]<- prob.1leaf.to.2leaf *recruit.size(y,params_list) * h
  
  # Growth/survival transitions among cts sizes
  Tmat[3:(n+2),3:(n+2)]<- t(outer(y,y,P,params=params_list)) * h 
  
  # Put it all together
  IPMmat<-Fmat+Tmat     #Full Kernel is simply a summation of fertility and transition matrix
  out_matrix <- list(IPMmat=IPMmat,Fmat=Fmat,Tmat=Tmat,meshpts=y)
  
  out_lamb <- data.frame(lambda = lambda(IPMmat), summer.temp = params_list$summer.mean.temp,  gs.temp = params_list$spring.mean.temp, winter.temp = params_list$winter.mean.temp, reproduction = params_list$reproduction, trt = params_list$trt)
 # return(out_matrix) #can check this to have a list of all of the matrices listed above
  return(out_lamb) #for now, I just want lambdas
 # return(list(out_matrix = out_matrix, out_lamb = out_lamb))

}

#what I want returned is lambdas
lamb_lists <- lapply(X = params_list, FUN = bigmatrix, mat.size = mat.size) #for each row of params_list, run the big matrix function!
#great~! now make it a df
primula_lambda <- do.call(rbind, lamb_lists)
#write.csv(primula_lambda, "../tables/primula.climate.lambdas.2023.01.09.csv", row.names = F)

(gs <- primula_lambda %>% 
  filter(summer.temp == 0 & winter.temp == 0) %>% 
  ggplot(aes(x = gs.temp, y = lambda, color = trt, linetype = reproduction))+
  geom_line(linewidth = 1.6)+
  facet_wrap(~trt)+
  scale_color_manual(values = c("#5f9034", "#e81014", "#2892c7"), name = "")+
  scale_fill_manual(values = c("#5f9034", "#e81014", "#2892c7"), name = "")+
  labs(y = expression(paste("\u03BB")), x = "Spring Temperature")+
  coord_cartesian(ylim = c(.8, 1.02))+ 
  geom_hline(yintercept = 1, color= "black", linewidth = .2)+
  scale_linetype_manual(values=c("dotted", "solid"), labels = c("vegetative", "flowered"), name = "") +  
  theme(strip.background = element_blank(), strip.text.x = element_blank(), axis.line = element_line(colour = 'black', linewidth = 1.1), 
        text = element_text(size = 20))) #remove facet wrap labels


(summer <- primula_lambda %>% 
  filter(gs.temp == 0 & winter.temp == 0) %>% 
  ggplot(aes(x = summer.temp, y = lambda, color = trt, linetype = reproduction))+
  geom_line(linewidth = 1.6)+
  facet_wrap(~trt)+
  scale_y_continuous(limits=c(.8,1.02))+ 
  scale_color_manual(values = c("#5f9034", "#e81014", "#2892c7"), name = "")+
  scale_fill_manual(values = c("#5f9034", "#e81014", "#2892c7"), name = "")+
  labs(y = expression(paste("\u03BB")), x = "Summer Temperature")+
  geom_hline(yintercept = 1, color= "black", linewidth = .2)+
  scale_linetype_manual(values=c("dotted", "solid"), labels = c("vegetative", "flowered"), name = "") +  
  theme(strip.background = element_blank(), strip.text.x = element_blank(), axis.line = element_line(colour = 'black', linewidth = 1.1), 
        text = element_text(size = 20))) #remove facet wrap labels


(winter <- primula_lambda %>% 
  filter(summer.temp == 0 & gs.temp == 0) %>% 
  ggplot(aes(x = winter.temp, y = lambda, color = trt, linetype = reproduction))+
  geom_line(linewidth = 1.6)+
  scale_y_continuous(limits=c(.8,1.02))+ 
  facet_wrap(~trt)+
  scale_color_manual(values = c("#5f9034", "#e81014", "#2892c7"), name = "")+
  scale_fill_manual(values = c("#5f9034", "#e81014", "#2892c7"), name = "")+
  labs(y = expression(paste("\u03BB")), x = "Winter Temperature")+
  scale_linetype_manual(values=c("dotted", "solid"), labels = c("vegetative", "flowered"), name = "") +  
  geom_hline(yintercept = 1, color= "black", linewidth = .2)+
  theme(strip.background = element_blank(), strip.text.x = element_blank(), axis.line = element_line(colour = 'black', linewidth = 1.1), 
        text = element_text(size = 20)))

#patch work package
(base.ipm <- gs + summer +  winter + plot_layout(guides = "collect", ncol = 1)+plot_annotation(tag_level = "A"))
#ggsave(plot = base.ipm, file = "C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/Figures/IPM/ipm base.png", width = 10, height = 10, dpi = 300)

```
###


```{r sensitivity}
#goal: examine sensitivity of parameters and discrete transition probabilities for appendix
#this is an ugly hard code but oh well
perturbation <- 0.01 #perturbation

sens.params <- params %>% 
  filter(summer.mean.temp == 0&
         winter.mean.temp == 0&
         spring.mean.temp == 0&
         trt == "control", 
         reproduction == "flowered")
sens.params$prob.seedling.to.1leaf <- prob.seedling.to.1leaf
sens.params$prob.1leaf.to.1leaf <- prob.1leaf.to.1leaf
sens.params$prob.1leaf.to.2leaf <- prob.1leaf.to.2leaf
sens.params$version <- "original"

sens.params.g.int <- sens.params %>% 
  mutate(growth.int = growth.int + perturbation,
         version = "growth.int")
sens.params.g.slope <- sens.params %>% 
  mutate(growth.slope = growth.slope + perturbation,
         version = "growth.slope")
sens.params.surv.int <- sens.params %>% 
  mutate(surv.int = surv.int + perturbation,
         version = "surv.int")
sens.params.surv.slope <- sens.params %>% 
  mutate(surv.slope = surv.slope + perturbation,
         version = "surv.slope")
sens.params.pflow.int <- sens.params %>% 
  mutate(pflow.int = pflow.int + perturbation,
         version = "pflow.int")
sens.params.pflow.slope <- sens.params %>% 
  mutate(pflow.slope = pflow.slope + perturbation,
         version = "pflow.slope")
sens.params.no.flow.int <- sens.params %>% 
  mutate(no.flow.int = no.flow.int + perturbation,
         version = "no.flow.int")
sens.params.no.flow.slope <- sens.params %>% 
  mutate(no.flow.slope = no.flow.slope + perturbation,
         version = "no.flow.slope")
sens.params.rec.size.mean <- sens.params %>% 
  mutate(recruit.size.mean = recruit.size.mean + perturbation,
         version = "recruit.size.mean")
sens.params.prob.seed.germ <- sens.params %>% 
  mutate(prob.seed.germ = prob.seed.germ + perturbation,
         version = "prob.seed.germ")
sens.params.prob.seedling.to.1leaf <- sens.params %>% 
  mutate(prob.seedling.to.1leaf = prob.seedling.to.1leaf + perturbation,
         version = "prob.seedling.to.1leaf")
sens.params.prob.1leaf.to.1leaf <- sens.params %>% 
  mutate(prob.1leaf.to.1leaf = prob.1leaf.to.1leaf + perturbation,
         version = "prob.1leaf.to.1leaf")
sens.params.prob.1leaf.to.2leaf <- sens.params %>% 
  mutate(prob.1leaf.to.2leaf = prob.1leaf.to.2leaf + perturbation,
         version = "prob.1leaf.to.2leaf")
sens <- mget(ls(pattern = "^sens.params")) #make a list of all of those models that start with ___ (^ means start with)

sens <- do.call("rbind", sens)

ltre_list <-  filter(sens) %>% split(., seq(nrow(.))) #this splits up params into X rows, which I can feed into the function below

#sensivity is 

# BIGMATRIX ---------------------------------------------------------------
#building off of code from Tom Miller:
mat.size = 100 #dimensions of continuous matrix
bigmatrix<-function(ltre_list, mat.size)
  {
  n<-mat.size
  L<-min.size
  U<-max.size
  #these are the upper and lower integration limits
  h<-(U-L)/n                   #Bin size
  b<-L+c(0:n)*h;               #Lower boundaries of bins 
  y<-0.5*(b[1:n]+b[2:(n+1)]);  #Bins' midpoints
  #these are the boundary points (b) and mesh points (y)

  # Fertility matrix
  Fmat<-matrix(0,(n+2),(n+2))
  
  # top row: # seedlings produced by each size class:
  Fmat[1,3:(n+2)]<-f.yx(y,ltre_list) #This is a y because it is the fecundity kernel for plants that have already grown/survived, I think? It's what Tom has
  
  # Growth/survival transition matrix
  Tmat<-matrix(0,(n+2),(n+2))
  
  # probability seedling becomes a 1 leaf plant
  Tmat[2,1]<- sens.params$prob.seedling.to.1leaf
  
   # probability 1 leaf plant stays as a 1 leaf plant
  Tmat[2,2]<- sens.params$prob.1leaf.to.1leaf
  
  # Graduation from 1 leaf to cts size = prob 1 leaf becomes a 2 leaf * size dist of new 2 leafers
  Tmat[3:(n+2),2]<- sens.params$prob.1leaf.to.2leaf *recruit.size(y,ltre_list) * h
  
  # Growth/survival transitions among cts sizes
  Tmat[3:(n+2),3:(n+2)]<- t(outer(y,y,P,params=ltre_list)) * h 
  
  # Put it all together
  IPMmat<-Fmat+Tmat     #Full Kernel is simply a summation of fertility and transition matrix
  out_matrix <- list(IPMmat=IPMmat,Fmat=Fmat,Tmat=Tmat,meshpts=y)
  
  out_lamb <- data.frame(lambda = lambda(IPMmat), summer.temp = ltre_list$summer.mean.temp,  gs.temp = ltre_list$spring.mean.temp, winter.temp = ltre_list$winter.mean.temp, reproduction = ltre_list$reproduction, trt = ltre_list$trt, version = ltre_list$version)
 #return(IPMmat) #can check this to have a list of all of the matrices listed above
  return(out_lamb) #for now, I just want lambdas
  #return(list(IPMmat = IPMmat, out_lamb = out_lamb))

}



#what I want returned is lambdas
lamb_lists <- lapply(X = ltre_list, FUN = bigmatrix, mat.size = mat.size) #for each row of params_list, run the big matrix function!

#great~! now make it a df
#ltre_lambda <- list(lamb_lists[[1]]$out_lamb, lamb_lists[[2]]$out_lamb)
ltre_lambda <- do.call("rbind", lamb_lists)
#now, sensitivity for each coefiicient:
ltre_lambda$sensitivity <- NA

#sens = lambda new - lambda old / perturbation
#SV <- (Lambda.p - Lambda) / perturbation

for (i in seq_len(nrow(ltre_lambda))){
  ltre_lambda$sensitivity[i] <- (ltre_lambda$lambda[i] - ltre_lambda$lambda[1])/perturbation
   ltre_lambda$sensitivity[1] <- NA
}
#nothing like a little hard coding!!!

#sensitivity of lambda to each parameter
(sens.fig <- ltre_lambda %>% filter(version != "original") %>% 
  ggplot(aes(x = version, y = sensitivity))+
  geom_point()+
  labs(x = "Vital Rate Coefficient", y = "Sensitivity of lambda to coefficient")+
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
)
#ggsave(plot = sens.fig, file = "C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/Figures/IPM/sensitivity.repro.png", width = 8, height =8, dpi = 300)

original <- as.data.frame(t(sens.params)) %>% 
  tibble::rownames_to_column("version") %>% 
  rename(coef = V1)
ltre_lambda <- left_join(ltre_lambda, original)

#Following IPM construction, calculate sensitivity and elasticity values (Eq. 2 & 3 in text in Griffith 2017)
#SV <- (Lambda.p - Lambda) / perturbation
ltre_lambda$elasticity <- NA
#EV <- SV * (VR.mod$coefficients[i] / Lambda)
ltre_lambda <- ltre_lambda %>% 
  mutate(elasticity = sensitivity * as.numeric(coef)/lambda)
ltre_lambda$vr <- c("na", "growth", "growth", "fecundity", "fecundity", "fecundity", "fecundity", "discrete", "discrete", "discrete", "discrete", "discrete", "survival", "survival")

#elasticity of lambda to each parameter
(elas.fig <- ltre_lambda %>% 
    filter(version != "original") %>% 
  ggplot(aes(x = version, y = elasticity, fill = vr))+
  geom_bar(stat = "identity")+
  labs(x = "Vital Rate Coefficients and Paramters", y = "Elasticity of lambda to parameter")+
          theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  scale_fill_manual(values = c("orange", "darkorchid", "#7aa560", "blue"))+
  geom_hline(yintercept = 0)+
  theme(legend.title=element_blank(), strip.background = element_blank(), strip.text.x = element_blank(), axis.line = element_line(colour = 'black', linewidth = 1.1), text = element_text(size = 20))
)
ggsave(plot = elas.fig, file = "C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/Figures/IPM/elas.repro.png", width = 8, height =8, dpi = 300)
#what drives the differences in lambda between non reproductive and reproductive individuals?
#the LTRE is: change in coefficient between control and treatment * sensitivity ofcoefficient in control

ltre.params <-  params %>% 
  filter(summer.mean.temp == 0&
         winter.mean.temp == 0&
         spring.mean.temp == 0&
         trt == "control")
ltre <- data.frame(growth.int = NA)

ltre$growth.int <-  ltre.params$growth.int[1]-ltre.params$growth.int[2]
ltre$growth.slope <- ltre.params$growth.slope[1]-ltre.params$growth.slope[2]
ltre$surv.int <- ltre.params$surv.int[1]-ltre.params$surv.int[2]
ltre$surv.slope <- ltre.params$surv.slope[1]-ltre.params$surv.slope[2]
ltre$pflow.int <- ltre.params$pflow.int[1]-ltre.params$pflow.int[2]
ltre$pflow.slope <- ltre.params$pflow.slope[1]-ltre.params$pflow.slope[2]
ltre$no.flow.int <- ltre.params$no.flow.int[1]-ltre.params$no.flow.int[2]
ltre$no.flow.slope <- ltre.params$no.flow.slope[1]-ltre.params$no.flow.slope[2]

ltre <- ltre %>% 
  pivot_longer(everything(), names_to = "version", values_to = "diff")

ltre <- left_join(ltre, ltre_lambda)
ltre <- ltre %>% 
  mutate(ltre = diff*sensitivity)
(ltre.fig <- ltre %>% 
  ggplot(aes(x = version, y = ltre))+
  geom_point()+
  labs(x = "Vital Rate Coefficient", y = "LTRE contribution (vegetative-reproductive)")+
  geom_hline(yintercept = 0, linetype = "dashed"))
ggsave(plot = ltre.fig, file = "C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/Figures/IPM/ltre repo.png", width = 8, height =8, dpi = 300)

```

```{r how many seedlings produced?}
#use this code to check and see how many seedlings are produced by each size class
matrix <- as.data.frame(save$IPMmat)
no.seedlings <- matrix[1,]
no.seedlings <- no.seedlings %>% pivot_longer(
    cols = starts_with("V"),
    values_to = "no.seedlings",
    names_to = "size",
    names_pattern = "V(.*)")
barplot(no.seedlings$no.seedlings, xlab = "Plant size (small to large)", ylab = "Number of seedlings produced")

#and use this code to see p(1 leaf becomes a 2 leaf)* size distribution of new individuals into kernel
new.cont <- matrix[3:102,2]
barplot(new.cont, ylab = "Prob. 1 leaf becomes >2 leaf * size distribution of new >2 leafs", xlab = "Plant size (small to large)")

```

How does p(establishing) affect lambda? Run a simulation. For appendix
```{r pest}
#make parameters for control and non reproductive plants under mean temperatures (more simple)
params.est <- params %>% 
  filter(trt == "control" & reproduction == "veg" & summer.mean.temp == 0 & winter.mean.temp == 0 & spring.mean.temp ==0)

#define range of p_est to test
pest_sample = data.frame(pest_sample = seq(0.001, 0.2, 0.001))

pest_sample <- cross_join(params.est, pest_sample)
```

```{r IPM for pest}
prob.seed.germ <- .022 #this is from the seed addition data - average seed has 0.022 chance of germination
#the actual numbers
prob.seedling.to.1leaf <- .03 
prob.1leaf.to.1leaf <- .41*.42 # p that it survives and probability it doesn't become a 2 leaf
prob.1leaf.to.2leaf <- .41*.58

prob_values = seq(0.01, 0.9, 0.01)

# BIGMATRIX ---------------------------------------------------------------
#building off of code from Tom Miller:
mat.size = 100 #dimensions of continuous matrix
#for range of prob. values, stick the one of interest in below function and in loop
# prob.seedling.to.1leaf # or:
# prob.1leaf.to.1leaf
# prob.1leaf.to.2leaf
bigmatrix<-function(params.est, mat.size, prob.1leaf.to.2leaf)
  {
  n<-mat.size
  L<-min.size
  U<-max.size
  #these are the upper and lower integration limits
  h<-(U-L)/n                   #Bin size
  b<-L+c(0:n)*h;               #Lower boundaries of bins 
  y<-0.5*(b[1:n]+b[2:(n+1)]);  #Bins' midpoints
  #these are the boundary points (b) and mesh points (y)

  # Fertility matrix
  Fmat<-matrix(0,(n+2),(n+2))
  
  # top row: # seedlings produced by each size class:
  Fmat[1,3:(n+2)]<-f.yx(y,params.est) #This is a y because it is the fecundity kernel for plants that have already grown/survived, I think? It's what Tom has
  
  # Growth/survival transition matrix
  Tmat<-matrix(0,(n+2),(n+2))
  
  # probability seedling becomes a 1 leaf plant
  Tmat[2,1]<- prob.seedling.to.1leaf
  
   # probability 1 leaf plant stays as a 1 leaf plant
  Tmat[2,2]<- prob.1leaf.to.1leaf
  
  # Graduation from 1 leaf to cts size = prob 1 leaf becomes a 2 leaf * size dist of new 2 leafers
  Tmat[3:(n+2),2]<- prob.1leaf.to.2leaf *recruit.size(y,params.est) * h
  
  # Growth/survival transitions among cts sizes
  Tmat[3:(n+2),3:(n+2)]<- t(outer(y,y,P,params=params.est)) * h 
  
  # Put it all together
  IPMmat<-Fmat+Tmat     #Full Kernel is simply a summation of fertility and transition matrix
  
  out_lamb <- data.frame(lambda = lambda(IPMmat))
  return(out_lamb) #for now, I just want lambdas
 # return(list(out_matrix = out_matrix, out_lamb = out_lamb))

}

# Create an empty list to store the results for each value of prob.seedling.to.1leaf
results_list <- list()

# Loop through each value of prob.seedling.to.1leaf
for (prob_value in prob_values) {
  # Call the bigmatrix function with the current prob_value
  result <- bigmatrix(params.est, mat.size, prob.1leaf.to.2leaf = prob_value)
  
  # Add the result to the list with an identifier
  results_list[[as.character(prob_value)]] <- result
}

#ok, that works! 
#add in the values used:
seed.to.leaf.lambda <- do.call(rbind, results_list)
seed.to.leaf.lambda <- tibble::rownames_to_column(seed.to.leaf.lambda, "prob.seedling.to.1leaf")

leaf.to.leaf.lambda <- do.call(rbind, results_list)
leaf.to.leaf.lambda <- tibble::rownames_to_column(leaf.to.leaf.lambda, "prob.1leaf.to.1leaf")

leaf.to.adult.lambda <- do.call(rbind, results_list)
leaf.to.adult.lambda <- tibble::rownames_to_column(leaf.to.adult.lambda, "prob.1leaf.to.2leaf")



(seed.to.leaf.lambda.fig <- 
    seed.to.leaf.lambda %>% 
  ggplot(aes(y = lambda, x = as.numeric(prob.seedling.to.1leaf)))+
  geom_line(linewidth = 1.5)+
  labs(x = "Probability of seedling becoming a 1-leaf plant", y = expression(paste("\u03BB")))+
  geom_vline(xintercept=prob.seedling.to.1leaf, linetype = "dashed")+
  scale_y_continuous(limits=c(.94,1.1))+ 
  expand_limits(x = 0)+
  coord_cartesian(expand = FALSE) +
  annotate(x=prob.seedling.to.1leaf+.12,y=+Inf,label="Value used in models",vjust=2,geom="label")
  )

(leaf.to.leaf.lambda.fig <- leaf.to.leaf.lambda %>% 
  ggplot(aes(y = lambda, x = as.numeric(prob.1leaf.to.1leaf)))+
  geom_line(linewidth = 1.5)+
  labs(x = "Probability of 1-leaf surviving and staying a 1-leaf plant", y = expression(paste("\u03BB")))+
  geom_vline(xintercept=prob.1leaf.to.1leaf, linetype = "dashed")+
  scale_y_continuous(limits=c(.94,1.1))+ 
  expand_limits(x = 0)+
  coord_cartesian(expand = FALSE) +
  annotate(x=prob.1leaf.to.1leaf,y=+Inf,label="Value used in models",vjust=2,geom="label"))

(leaf.to.adult.lambda.fig <- leaf.to.adult.lambda %>% 
  ggplot(aes(y = lambda, x = as.numeric(prob.1leaf.to.2leaf)))+
  geom_line(linewidth = 1.5)+
  labs(x = "Probability of 1-leaf surviving and growing to an adult plant", y = expression(paste("\u03BB")))+
  geom_vline(xintercept=prob.1leaf.to.2leaf, linetype = "dashed")+
  scale_y_continuous(limits=c(.94,1.1))+ 
  expand_limits(x = 0)+
  coord_cartesian(expand = FALSE) +
  annotate(x=prob.1leaf.to.2leaf,y=+Inf,label="Value used in models",vjust=2,geom="label"))

#patch these together
(together <- seed.to.leaf.lambda.fig + leaf.to.leaf.lambda.fig +leaf.to.adult.lambda.fig + plot_annotation(tag_levels = 'A') +plot_layout(ncol = 1))

#ggsave(plot = together, file = "C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/Figures/IPM/pest.simulations.tagged2.png", width = 6, height = 10, dpi = 300)
```

