---
title: "primula_IPM"
author: "JL"
date: "3/2/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(AICcmodavg)
library(lme4)
library(popbio)
theme_set(theme_classic()) #for ggplot
```

DONE- To do: use sarah's code with the townsendia solution to having multiple growth functions feed into one IPM big marrix!
first, just write out the params to have 6 rows (for each combination of reproduction and trt! ) 
    - What I ended up doing: making the params df "long", so each row was for a specific trt and reproduction, and then feeding each row into the big matrix. And it works! Great!!
    
    Next Steps:
    -Add temperature in! Make a loop for the parameters
    -Figure out whats happening with those tags in the cleaning script

```{r}
#this is code from Sarah that has one function for the townsendia df!! I've edited it below to get it to work for the primula data
# 
#  g.yx<-function(lifehist, xp,x,params){
#    xb=pmin(pmax(x,minRealsize),maxRealsize) #Transforms all values below/above limits in min/max size (floor & ceiling)
#    if (lifehist=="Apo"){
#          growth_to_newsize <-params$growth.int.A + params$growth.slope*xb
#          growth_sd <- params$growth.sd
#          return(dnorm(xp,mean=growth_to_newsize,sd=growth_sd))}
#    else if(lifehist=="Sex"){
#          growth_to_newsize <-params$growth.int.S + params$growth.slope*xb
#          growth_sd <- params$growth.sd
#          return(dnorm(xp,mean=growth_to_newsize,sd=growth_sd))}
#  }
# params_list <-  filter(params) %>% split(., seq(nrow(.)))
# 
# ### use the map function to change the inputs and so you can just write 1 function 
# BFM <- function(params_in, y){
#     if(exists('g.yx.A') == FALSE){
#         print('missing g.yx.A function?')
#     }
#     
#     repro_type = params_in[,'Reproduction']
#     if(repro_type == "Sex"){
#         G.S=h*outer(y,y,g.yx.S,params=params_in) 	# growth kernel
#     S=s.x(y,params=params_in) 				# survival
#     P.S=G.S 								# placeholder;redefine P on the next line
#     for(i in 1:n) P.S[,i]=G.S[,i]*S[i]  	# growth/survival kernel
#     F=h*outer(y,y,f.yx,params=params_in) 	    # reproduction kernel
#             K.S=P.S+F 						# full kernel
# 
#     lambsite_ <-lambda(K.S) 
#     }
#     else if (repro_type == "Apo"){
#     G.A=h*outer(y,y,g.yx.A,params=params_in) 	# growth kernel
#     S=s.x(y,params=params_in) 				# survival
#     P.A=G.A 								# placeholder;redefine P on the next line
#     for(i in 1:n) P.A[,i]=G.A[,i]*S[i]  	# growth/survival kernel
#     F=h*outer(y,y,f.yx,params=params_in) 	    # reproduction kernel
#             K.A=P.A+F 						# full kernel
# 
#     lambsite_ <-lambda(K.A)  
#     }
#     out_c <- data.frame(site = params_in$Site, lambda= lambsite_)
# return(out_c)
# }
# 
# model_out <- params_list %>% map(., .f = BFM, y = y) %>% bind_rows()

```


- _what do f.yx functions need to return? Just number of seedlings? so some thing like the pf functions?_
-For the most part, I've just taken the average/made up the misc components. Which is fine for now but eventually will need to be dealt with!
- I think Tom's code can help me figure out how to not have separate functions for each treatment (ie use some form of ifelse)



```{r}
### read in all years of Primula data and weather data from the Cowichan
# Add in climate data:
source("../scripts/Cowichan_climatevalues.R")

# Add in demography data:
source("../scripts/dode_allyears_cleaned.R")
#if this doesn't run, it's probably something weird with markdown - go into that R script and change the dormancy read.csv to have ".." instead of "." at the beginning

## Join climate data to demography data by year
primula <- left_join(Dodecatheon, climate, by = "year") %>% 
  mutate(psurvivalT1 = as.factor(psurvivalT1))

remove(Dodecatheon)

#gives a warning but I think it's fine!

new.plants <- primula %>%   
  mutate(leaves = if_else(year == 2022, no.smleaf + no.bigleaf, leaves)) %>% 
  filter(year == YrTag) %>% ##need to filter cases where year tagged == year (so newly tagged that year)
  filter(pflower == 0) %>% ## actual new plants definitely can't flower in the first year
  filter(leaves < 3) %>% 
  filter(!is.na(log.ros.area))
```




Eventually do to:
-add in image of life cycle diagram
- think more about climate variables - what if I switch to average temperature instead of min/max? To reduce number of models. Also, potentially could just look at spring/growing season climate (ie when the plants are out and growing)


##IPM for Primula data
```{r}
#load best fit models from primula_climate_VR.r"
# 
# gm17 <- lmer(log.ros.areaT1 ~ log.ros.area + trt * grow.season.mean.max.temp+ (1|plot) + (1|year), data = primula) ###
#   growth_var <- as.data.frame(VarCorr(gm17)) #assumes same variance across all, not sure if thats ok
# fm.f16 <- glmer(pflowerT1 ~ log.ros.area * pflower + grow.season.mean.max.temp+ (1|plot) + (1|year), data = primula, family = "binomial")
# sm10lag <- glmer(psurvivalT1 ~ log.ros.area*grow.season.min.temp.1yearlag+ (1|plot) + (1|year), data = primula, family = "binomial") ###
# noflow9 <- glm(flow.sum ~ log.ros.area + grow.season.mean.min.temp, data = subset(primula, flow.sum > 0), family = "poisson")

fm.base.cor.int <- glmer(pflowerT1 ~ log.ros.area*as.factor(pflower) + (1|plot) + (1|year), data = primula, family = "binomial")
sm.gs.av.temp <- glmer(psurvivalT1 ~ log.ros.area + grow.season.mean.mean.temp + (1|plot) + (1|year), data = primula, family = "binomial")
gm.gs.precip.cor.int3 <- lmer(log.ros.areaT1 ~ log.ros.area*as.factor(pflower)*grow.season.tot.precip + (1|plot) + (1|year), data = primula, REML = F)
noflowers.base.cor <- glmer(flow.sum ~ log.ros.area + pflower + (1|plot) + (1|year), data = subset(primula, flow.sum > 0), family = "poisson")
seed3  <- glmer(total.seeds~log.ros.area*trt + (1|year)+ (1|plot), data = subset(primula, total.seeds >0), family = "poisson")


growth_var <- as.data.frame(VarCorr(gm.gs.precip.cor.int3)) #assumes same variance across all, not sure if thats ok
coef(summary(gm.gs.precip.cor.int3))
#coef(fm.base.cor.int)

```


###




Then the other miscellany we'll need (size independent parameters):

GOAL FOR 4/5: just make some these up for now and make a model that runs!
```{r}

prob.flower.makes.seeds <- 0.73 #this is a made up number
## I need to change this because this is treatment dependent!
no.seeds <- 36 #if you make seeds, this is on averge how many seeds you make 
prob.seed.germ <- .001 #made up, will change later (after seed addition data comes in )
prob.seedling.to.1leaf <- .1
prob.1leaf.to.1leaf <- .1
prob.1leaf.to.2leaf <- .1

#eventually this might change if we want treatment specific size of new recruits - will look into it more
new_sd <- sd(new.plants$log.ros.area)
new_mean <- mean(new.plants$log.ros.area)

```

Define the min and max size, which are the integration bounds of the IPM.
```{r size bounds, echo=T}
minRealsize <- min(primula$log.ros.area, na.rm=T) 

maxRealsize <- 1.1* max(primula$log.ros.area,na.rm=T)

#now add a new min & max size to keep the plants in for eviction
#note - this was code from Townsenia code - will need to revisit for Primula!
min.size <-minRealsize-1 #lower
max.size <-maxRealsize+1.5 #upper
```
## Collect model parameters into a vector

This is a little tricky! There are a lot of variables in the models, so be careful here with the equations for the mixed models
Also ~ how do deal with temperature in these?? Just add the variable in to get the slope??
I've just added in the mean temp, so these are specific to one specific temperature (in the future, I can write a loop to get a range of temperatures?)


```{r parameter vector, echo=FALSE}

# pflower

# av.grow.max.temp <- climate_percentiles$maxT_mean[1]
# av.grow.min.temp <- climate_percentiles$minT_mean[1]
#rows <- expand.grid(precip= c(mean(climate$grow.season.tot.precip), min(climate$grow.season.tot.precip), max(climate$grow.season.tot.precip)), temp = c(mean(climate$grow.season.mean.mean.temp), min(climate$grow.season.mean.mean.temp), max(climate$grow.season.mean.mean.temp)), reproduction = c("veg","flowered"))
rows <- expand.grid(precip= seq(min(climate$grow.season.tot.precip), max(climate$grow.season.tot.precip), by = 25), temp = seq(min(climate$grow.season.mean.mean.temp), max(climate$grow.season.mean.mean.temp), by = .75), reproduction = c("veg","flowered"))
rows <- rows %>% mutate(temp = round(temp, 2))

params=data.frame(
	growth.int = c(NA),
	#growth.int.control = c(NA,NA, NA, NA, NA, NA),
	#growth.int.irr = NA,
	#growth.int.drought = NA,
	growth.slope  = NA,
	#growth.slope.irr = NA,
	#growth.slope.drought = NA,
	growth.sd=NA,
	
	surv.int=NA,
	surv.slope=NA,
	
	pflow.int = NA,
	#pflow.int.flowered=NA,
	#pflow.int.veg=NA,
	pflow.slope = NA,
	#pflow.slope.flowered=NA,
	#pflow.slope.veg=NA,
	
	no.flow.int=NA,
	no.flow.slope=NA,
	no.seeds.int=NA,
	no.seeds.slope=NA,
	
	recruit.size.mean=NA,
	recruit.size.sd=NA,
	
	p.flower.makes.seed=NA,
	no.seeds = NA,
	prob.seed.germ = NA
	#pdorm.int=NA
)
params <- bind_cols(params, rows)

#params$trt <- c("irrigated", "irrigated", "control", "control", "drought", "drought")
##params$reproduction <- c("flowered", "veg")
#params$precip <- c(mean(climate$grow.season.tot.precip), min(climate$grow.season.tot.precip), max(climate$grow.season.tot.precip))
#params$temp <- c(mean(climate$grow.season.mean.mean.temp), min(climate$grow.season.mean.mean.temp), max(climate$grow.season.mean.mean.temp))

#gm.gs.precip.cor.int3 <- lmer(log.ros.areaT1 ~ log.ros.area*pflower*grow.season.tot.precip + (1|plot) + (1|year), data = primula, REML = F)



#growth intercepts
for (i in 1:length(params$growth.int[params$reproduction == "veg"])) {
  params$growth.int[params$reproduction == "veg"][i] <- fixef(gm.gs.precip.cor.int3)[1] + fixef(gm.gs.precip.cor.int3)[4]*params$precip[i]
  params$growth.int[params$reproduction == "flowered"][i] <- fixef(gm.gs.precip.cor.int3)[1] + fixef(gm.gs.precip.cor.int3)[4]*params$precip[i] + fixef(gm.gs.precip.cor.int3)[3] + fixef(gm.gs.precip.cor.int3)[7]*params$precip[i]
}
# params$growth.int[params$trt == "irrigated"] <-fixef(gm17)[1] + fixef(gm17)[4] + fixef(gm17)[5]*av.grow.max.temp +   fixef(gm17)[7]*av.grow.max.temp
# params$growth.int[params$trt == "drought"] <- fixef(gm17)[1] + fixef(gm17)[3] + fixef(gm17)[5]*av.grow.max.temp + fixef(gm17)[6]*av.grow.max.temp

#things get messy here, check that these all make sense...[can add written out equations here...]
# params$growth.int.control <- fixef(gm17)[1] + fixef(gm17)[5]*av.grow.max.temp # growth intercept for control
# params$growth.int.drought <- fixef(gm17)[1] + fixef(gm17)[3] + fixef(gm17)[5]*av.grow.max.temp + fixef(gm17)[6]*av.grow.max.temp # growth intercept for drought
# params$growth.int.irr <- fixef(gm17)[1] + fixef(gm17)[4] + fixef(gm17)[5]*av.grow.max.temp + fixef(gm17)[7]*av.grow.max.temp# growth intercept for irr

#slope for growth
for (i in 1:length(params$growth.slope[params$reproduction == "veg"])) {
  params$growth.slope[params$reproduction == "veg"][i] <- fixef(gm.gs.precip.cor.int3)[2] + fixef(gm.gs.precip.cor.int3)[6]*params$precip[i]
  params$growth.slope[params$reproduction == "flowered"][i] <- fixef(gm.gs.precip.cor.int3)[2] + fixef(gm.gs.precip.cor.int3)[6]*params$precip[i]+ fixef(gm.gs.precip.cor.int3)[5]+ fixef(gm.gs.precip.cor.int3)[8]*params$precip[i]
}

params$growth.sd <- growth_var[growth_var$grp=="Residual","sdcor"] # growth sd of residuals


#sm.gs.av.temp- i think there needs to be a loop here for each temp value - yes great
for (i in 1:length(params$temp)) {
  params$surv.int[i] <- fixef(sm.gs.av.temp)[1] + fixef(sm.gs.av.temp)[3]*params$temp[i]
}
 # survival slope
params$surv.slope <- fixef(sm.gs.av.temp)[2] # survival size t

#params$pflow.int[params$reproduction == "veg"] <- fixef(fm.f16)[1] + fixef(fm.f16)[4]*av.grow.max.temp # probability of flowering intercept for pflower == 0
params$pflow.int[params$reproduction == "veg"] <- fixef(fm.base.cor.int)[1] # probability of flowering intercept for pflower == 0
# params$pflow.int[params$reproduction == "flowered"] <- fixef(fm.f16)[1] + fixef(fm.f16)[3] + fixef(fm.f16)[4]*av.grow.max.temp # probability of flowering intercept
params$pflow.int[params$reproduction == "flowered"] <- fixef(fm.base.cor.int)[1] + fixef(fm.base.cor.int)[3] # probability of flowering intercept


params$pflow.slope[params$reproduction == "veg"] <- fixef(fm.base.cor.int)[2] # probability of flowering slope for veg plants
params$pflow.slope[params$reproduction == "flowered"] <- fixef(fm.base.cor.int)[2] + fixef(fm.base.cor.int)[4] # probability of flowering slope for flowered plants

params$no.flow.int <- fixef(noflowers.base.cor)[1] 
params$no.flow.slope <- fixef(noflowers.base.cor)[2] # flower number production size t

#params$pdorm.int <-fixef(dorm_model)[1] #intercept of dormancy model to calculate prob of dormancy (not size dependent)
#note that the IPM doesn't use dormancy parameter or the dormancy model

params$p.flower.makes.seed <- prob.flower.makes.seeds
params$no.seeds <- no.seeds
params$prob.seed.germ <- prob.seed.germ
params$recruit.size.mean <- new_mean # mean new >1 leaf plant size
params$recruit.size.sd<- new_sd # sd of new >1 leaf plant size

```

# Build the model!

### Step 1. Build vital rate functions (components of the kernel)

```{r VR functions}
###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
###         Load functions
###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#SURVIVAL AT SIZE X
s.x=function(x,params) {
	u=exp(params$surv.int+params$surv.slope*x)
	return(u/(1+u))
    }

#GROWTH FROM SIZE X TO XP for CONTROL...here ive changed xp to y, as per Tom's code (I think that what makes the big matrix function work in the end...)
  # Currently, seperate functions for growth for each IDE treatment. 
  ## returns a *probability density distribution* for each x value
#g.yx.control<-function(y,x,params){
    #ignoring eviction here...this code will eventually fix it
  #xb=pmin(pmax(x,minRealsize),maxRealsize) #Transforms all values below/above limits in min/max size (floor & ceiling)
  #growth_to_newsize <-params$growth.int.control + params$growth.slope*xb
  #growth_sd <- params$growth.sd
  #return(dnorm(y,mean=growth_to_newsize,sd=growth_sd))
 # dnorm(y,mean=params$growth.int.control + params$growth.slope*x,sd=params$growth.sd)

#}

#GROWTH FROM SIZE X TO Y for DROUGHT
#g.yx.drought<-function(y,x,params){
    #ignoring eviction here...
  #xb=pmin(pmax(x,minRealsize),maxRealsize) #Transforms all values below/above limits in min/max size (floor & ceiling)
  #growth_to_newsize <-params$growth.int.drought + params$growth.slope*x
  #growth_sd <- params$growth.sd
  #return(dnorm(y,mean=growth_to_newsize,sd=growth_sd))
  #dnorm(y,mean=params$growth.int.drought + params$growth.slope*x,sd=params$growth.sd)

#}
#GROWTH FROM SIZE X TO Y; just using one function! No need to seperate it out for each trt. Later on different params will be fed into this
g.yx<-function(y,x,params){
    #ignoring eviction here...
  #xb=pmin(pmax(x,minRealsize),maxRealsize) #Transforms all values below/above limits in min/max size (floor & ceiling)
  #growth_to_newsize <-params$growth.int.irr + params$growth.slope*xb
  #growth_sd <- params$growth.sd
  #return(dnorm(y,mean=growth_to_newsize,sd=growth_sd))
  dnorm(y,mean=params$growth.int + params$growth.slope*x,sd=params$growth.sd)

}

#Tom Miller's combined s and g kernel
P <- function(y, x, params){
  s.x(x, params)*g.yx(y, x, params)
}
# P.irr <- function(y, x, params){
#   s.x(x, params)*g.yx.irr(y, x, params)
# }
# P.drought <- function(y, x, params){
#   s.x(x, params)*g.yx.drought(y, x, params)
# }


#PROBABILITY OF FLOWERING OF SIZE X individuals that flowered:
# pf.x.flowered <-function(x,params){
# 	u<-exp(params$pflow.int.flowered+params$pflow.slope.flowered*x)
# 	return(u/(1+u))
# 	}
#PROBABILITY OF FLOWERING OF SIZE X individuals that did not flower:
pf.x <-function(x,params){
	u<-exp(params$pflow.int+params$pflow.slope*x)
	return(u/(1+u))
}


# #PRODUCTION OF seedlings by X-SIZED plants that flowered the previous year
###Here i've put in the misc bits, but not sure if this is correct - seems ok for now

# f.yx.flowered=function(x,params) { 		
# 	return(pf.x.flowered(x,params)*
#     exp(params$no.flow.int+params$no.flow.slope*x)*
#     params$p.flower.makes.seed*
#     params$no.seeds* #this will eventually be a function??
#     params$prob.seed.germ)
#  #is this right? I want a number of seedlings that are made.
# }

f.yx=function(x,params) { 		
	return(pf.x(x,params)*exp(params$no.flow.int+params$no.flow.slope*x)*
    params$p.flower.makes.seed*params$no.seeds*params$prob.seed.germ)
}

#SIZE DISTRIBUTION OF RECRUITS - separate function (before was part of f.yx). Now it feeds into a stage so won't be feeding back into the kernel
recruit.size<-function(y,params){
    ## returns a *probability density distribution*
  dnorm(y,mean=params$recruit.size.mean,sd=params$recruit.size.sd)
}
```

```{r setting up stage matrices}
params_list <-  filter(params) %>% split(., seq(nrow(.))) #this splits up params into 18 rows, which I can feed into the function below
#params_in <- params_list[[1]] #to test it!
# BIGMATRIX ---------------------------------------------------------------
#building off of code from Tom Miller:
mat.size = 100 #dimensions of continuous matrix
bigmatrix<-function(params_list, mat.size)
  {
  n<-mat.size
  L<-min.size
  U<-max.size
  #these are the upper and lower integration limits
  h<-(U-L)/n                   #Bin size
  b<-L+c(0:n)*h;               #Lower boundaries of bins 
  y<-0.5*(b[1:n]+b[2:(n+1)]);  #Bins' midpoints
  #these are the boundary points (b) and mesh points (y)

  # Fertility matrix
  Fmat<-matrix(0,(n+2),(n+2))
  
  # top row: # seedlings produced by each size class:
  Fmat[1,3:(n+2)]<-f.yx(y,params_list) #This is a y because it is the fecundity kernel for plants that have already grown/survived, I think? It's what Tom has
  
  # Growth/survival transition matrix
  Tmat<-matrix(0,(n+2),(n+2))
  
  # probability seedling becomes a 1 leaf plant
  Tmat[2,1]<- prob.seedling.to.1leaf
  
   # probability 1 leaf plant stays as a 1 leaf plant
  Tmat[2,2]<- prob.1leaf.to.1leaf
  
  # Graduation from 1 leaf to cts size = prob 1 leaf becomes a 2 leaf * size dist of new 2 leafers
  Tmat[3:(n+2),2]<- prob.1leaf.to.2leaf *recruit.size(y,params_list) * h
  
  # Growth/survival transitions among cts sizes
  Tmat[3:(n+2),3:(n+2)]<- t(outer(y,y,P,params=params_list)) * h 
  
  # Put it all together
  IPMmat<-Fmat+Tmat     #Full Kernel is simply a summation of fertility and transition matrix
  out_matrix <- list(IPMmat=IPMmat,Fmat=Fmat,Tmat=Tmat,meshpts=y)
  
  out_lamb <- data.frame(lambda = lambda(IPMmat), precip = params_list$precip, temp = params_list$temp, reproduction = params_list$reproduction)
  #return(out_matrix) #can check this to have a list of all of the matrices listed above
  return(out_lamb) #for now, I just want lambdas

}

#what I want returned is 6x lambdas
lamb_lists <- lapply(X = params_list, FUN = bigmatrix, mat.size = mat.size) #for each row of params_list, run the big matrix function!
#great~! now make it a df
primula_lambda <- do.call(rbind, lamb_lists)


#code from meeting with Sarah that worked on the townsenia problem! Above I came up with a better solution for the primula data
#model_out <- params_list %>% map(., .f = bigmatrix, params = params_list,
#                            mat.size = mat.size) %>% bind_rows()


#this is code that works for just one set of params
# primula_lambda <- bigmatrix(params = params_in,
#                             mat.size = mat.size)
# lambda(primula_lambda$IPMmat)

image(primula_lambda$IPMmat,main='full kernel - control flowered')	
image(primula_lambda$Fmat,main='F kernel - control flowered')	
image(primula_lambda$Tmat,main='S+G kernel - control flowered')	
abline(0,1,lwd=3)	


#definitely individuals are being evicted. who is the dark square on bottom left? Oh right it is the stage transitions
## And I'm not sure that the F kernel - axis should be flipped, anyway
```



```{r}
#now to make a graph:

ipm <- primula_lambda %>% 
  ggplot(aes(x = precip, y = lambda, linetype = reproduction))+
  geom_line(data = subset(primula_lambda, temp == 8.14), aes(x = precip, y = lambda), color = "lightblue2",  size = 1.25)+
  geom_line(data = subset(primula_lambda, temp == 9.64), aes(x = precip, y = lambda), color = "darkgrey", size = 1.25)+
  geom_line(data = subset(primula_lambda, temp == 11.14), aes(x = precip, y = lambda), color = "firebrick", size = 1.25)+
  labs(x = "Growing Season Total Precipitation (mm)", y = "Lambda")+
  scale_linetype_manual(values=c("longdash", "solid"))+
  theme(legend.position="none")

# ggplot(primula_lambda, aes(x = precip, y = lambda, fill = temp)) +
#   geom_tile(color = "black") +
#   scale_fill_gradient(low = "white", high = "red")

ggsave(plot = ipm, file = "C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/Figures/ipm climate.png", width = 5, height = 5, dpi = 300)

```




```{r}
#this is the clunky way to do it!!

#growth kernels - separate for each IDE treatment
G.control=h*outer(y,y,g.yx.control,params=params) 	# growth kernel
image(y,y,t(G.control),main='growth kernel - control') # plot it

G.drought=h*outer(y,y,g.yx.drought,params=params) 	# growth kernel
image(y,y,t(G.drought),main='growth kernel - drought') # plot it

G.irr=h*outer(y,y,g.yx.irr,params=params) 	# growth kernel
image(y,y,t(G.irr),main='growth kernel - irrigated') # plot it

S=s.x(y,params=params) 				# survival 
plot(y,S,type='l',main='survival')	# plot it

P.control=G.control 									# placeholder;redefine P on the next line
for(i in 1:n) P.control[,i]=G.control[,i]*S[i]  		# growth/survival kernel
image(y,y,t(P.control),main='survival/growth kernel - control')	# plot it
abline(0,1,lwd=3)						# plot 1:1, which represents stasis

P.drought=G.drought									# placeholder;redefine P on the next line
for(i in 1:n) P.drought[,i]=G.drought[,i]*S[i]  		# growth/survival kernel
image(y,y,t(P.drought),main='survival/growth kernel - drought')	# plot it
abline(0,1,lwd=3)						# plot 1:1, which represents stasis

P.irr=G.irr								# placeholder;redefine P on the next line
for(i in 1:n) P.irr[,i]=G.irr[,i]*S[i]  		# growth/survival kernel
image(y,y,t(P.irr),main='survival/growth kernel - irrigated')	# plot it
abline(0,1,lwd=3)						# plot 1:1, which represents stasis



F.flower=h*outer(y,y,f.yx.flowered,params=params) 	# reproduction kernel
image(y,y,t(F.flower),main='fecundity kernel for plants that flowered previous year')	# plot it

F.veg=h*outer(y,y,f.yx.veg,params=params) 	# reproduction kernel
image(y,y,t(F.veg),main='fecundity kernel for plants that did not flower previous year')	# plot it
####

K.drought.flow=P.drought+F.flower 															# full kernel for 
image(y,y,t(K.drought.flow),main='full kernel - drought plants that flowered in year-1')			# plot it

K.drought.veg=P.drought+F.veg 															# full kernel for 
image(y,y,t(K.drought.veg),main='full kernel - drought plants that didnt flower in year-1')			# plot it

K.irr.flow=P.irr+F.flower 															# full kernel for 
image(y,y,t(K.irr.flow),main='full kernel - irr plants that flowered in year-1')			# plot it

K.irr.veg=P.irr+F.veg 															# full kernel for 
image(y,y,t(K.irr.veg),main='full kernel - irr plants that didnt flower in year-1')			# plot it

K.control.flow=P.control+F.flower 															# full kernel for 
image(y,y,t(K.control.flow),main='full kernel - control plants that flowered in year-1')			# plot it

K.control.veg=P.control+F.veg 															# full kernel for 
image(y,y,t(K.control.veg),main='full kernel - control plants that didnt flower in year-1')			# plot it

lambda(K.drought.flow)
lambda(K.drought.veg)
lambda(K.irr.flow)
lambda(K.irr.veg)
lambda(K.control.flow)
lambda(K.control.veg)


```
Ok! These run! Obviously some things are missing and will need to change, but at least I get some lambdas! 

What does it mean to compare lambda across these? Can we just think about fitness here??
Wait, why is lambda for ones that flowered in t-1 HIGHER than ones that didn't flower?????
That seems really weird...will think about it more
At least drought lambda is lower, although control and irrigated arent that different
