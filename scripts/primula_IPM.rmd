---
title: "primula_IPM"
author: "JL"
date: "3/2/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(AICcmodavg)
library(lme4)
library(popbio)
theme_set(theme_classic()) #for ggplot
library(wesanderson) # for colors
Z <- wes_palettes$Zissou1

```



```{r}
#this is code from Sarah that has one function for the townsendia df!! I've edited it below to get it to work for the primula data
# 
#  g.yx<-function(lifehist, xp,x,params){
#    xb=pmin(pmax(x,minRealsize),maxRealsize) #Transforms all values below/above limits in min/max size (floor & ceiling)
#    if (lifehist=="Apo"){
#          growth_to_newsize <-params$growth.int.A + params$growth.slope*xb
#          growth_sd <- params$growth.sd
#          return(dnorm(xp,mean=growth_to_newsize,sd=growth_sd))}
#    else if(lifehist=="Sex"){
#          growth_to_newsize <-params$growth.int.S + params$growth.slope*xb
#          growth_sd <- params$growth.sd
#          return(dnorm(xp,mean=growth_to_newsize,sd=growth_sd))}
#  }
# params_list <-  filter(params) %>% split(., seq(nrow(.)))
# 
# ### use the map function to change the inputs and so you can just write 1 function 
# BFM <- function(params_in, y){
#     if(exists('g.yx.A') == FALSE){
#         print('missing g.yx.A function?')
#     }
#     
#     repro_type = params_in[,'Reproduction']
#     if(repro_type == "Sex"){
#         G.S=h*outer(y,y,g.yx.S,params=params_in) 	# growth kernel
#     S=s.x(y,params=params_in) 				# survival
#     P.S=G.S 								# placeholder;redefine P on the next line
#     for(i in 1:n) P.S[,i]=G.S[,i]*S[i]  	# growth/survival kernel
#     F=h*outer(y,y,f.yx,params=params_in) 	    # reproduction kernel
#             K.S=P.S+F 						# full kernel
# 
#     lambsite_ <-lambda(K.S) 
#     }
#     else if (repro_type == "Apo"){
#     G.A=h*outer(y,y,g.yx.A,params=params_in) 	# growth kernel
#     S=s.x(y,params=params_in) 				# survival
#     P.A=G.A 								# placeholder;redefine P on the next line
#     for(i in 1:n) P.A[,i]=G.A[,i]*S[i]  	# growth/survival kernel
#     F=h*outer(y,y,f.yx,params=params_in) 	    # reproduction kernel
#             K.A=P.A+F 						# full kernel
# 
#     lambsite_ <-lambda(K.A)  
#     }
#     out_c <- data.frame(site = params_in$Site, lambda= lambsite_)
# return(out_c)
# }
# 
# model_out <- params_list %>% map(., .f = BFM, y = y) %>% bind_rows()

```


- _what do f.yx functions need to return? Just number of seedlings? so some thing like the pf functions?_
-For the most part, I've just taken the average/made up the misc components. Which is fine for now but eventually will need to be dealt with!
- I think Tom's code can help me figure out how to not have separate functions for each treatment (ie use some form of ifelse)



```{r}
### read in all years of Primula data and weather data from the Cowichan
# Add in climate data:
source("../scripts/Cowichan_climatevalues.R")

# Add in demography data:
# Add in demography data:
source("../scripts/dode_allyears_cleaned.R")

## Join climate data to demography data by year
primula <- left_join(Dodecatheon, climate_scale, by = "year") %>%
  mutate(pflower = as.factor(pflower),
         pflowerT1 = as.factor(pflowerT1),
         psurvivalT1 = as.factor(psurvivalT1))

remove(climate, climate_scale, Dodecatheon)

#these are for the new plants - we wren't consistent with what we called a new adult
new.plants <- primula %>%   
  mutate(leaves = if_else(year == 2022, no.smleaf + no.bigleaf, leaves)) %>% 
  filter(year == YrTag) %>% ##need to filter cases where year tagged == year (so newly tagged that year)
  filter(pflower == 0) %>% ## actual new plants definitely can't flower in the first year
  filter(leaves < 3) %>% ## can't have more than 3 leaves
  filter(!is.na(log.ros.area))
```



##IPM for Primula data
```{r}
#number of bootstrap samples:
boot = 5
###


fm.gs.av.temp.cor.int1 <- glmer(pflowerT1 ~ log.ros.area*pflower + grow.season.mean.temp + (1|plot) + (1|year), data = primula, family = "binomial")
#parametric bootstrap
require(MASS)
#make matrix of random draws
pflower_samp = mvrnorm(n=boot, mu=fixef(fm.gs.av.temp.cor.int1), Sigma=vcov(fm.gs.av.temp.cor.int1))
pflower_samp
apply(pflower_samp,2,mean) #double check that the means are similar to fixef
fixef(fm.gs.av.temp.cor.int1)


####
sm.gs.av.temp <- glmer(psurvivalT1 ~ log.ros.area + grow.season.mean.temp + (1|plot) + (1|year), data = primula, family = "binomial")
#parametric bootstrap
require(MASS)
#make matrix of random draws
psurv_samp = mvrnorm(n=boot, mu=fixef(sm.gs.av.temp), Sigma=vcov(sm.gs.av.temp))
psurv_samp
apply(psurv_samp,2,mean) #double check that the means are similar to fixef
fixef(sm.gs.av.temp)
###

gm.summer.av.temp.cor.trt.int6 <- lmer(log.ros.areaT1 ~ log.ros.area*pflower + trt*summer.mean.temp + (1|plot) + (1|year), data = primula, REML = F)
#parametric bootstrap
require(MASS)
#make matrix of random draws
grow_samp = mvrnorm(n=boot, mu=fixef(gm.summer.av.temp.cor.trt.int6), Sigma=vcov(gm.summer.av.temp.cor.trt.int6))
grow_samp
apply(grow_samp,2,mean) #double check that the means are similar to fixef
fixef(gm.summer.av.temp.cor.trt.int6)

#variance for growth:
growth_var <- as.data.frame(VarCorr(gm.summer.av.temp.cor.trt.int6)) #assumes same variance across all
###

noflowers.winter.av.temp <- glmer(flow.sumT1 ~ log.ros.area + winter.mean.temp + (1|plot) + (1|year), data = subset(primula, flow.sumT1 > 0), family = "poisson")
#parametric bootstrap
require(MASS)
#make matrix of random draws
noflowers_samp = mvrnorm(n=boot, mu=fixef(noflowers.winter.av.temp), Sigma=vcov(noflowers.winter.av.temp))
noflowers_samp
apply(noflowers_samp,2,mean) #double check that the means are similar to fixef
fixef(noflowers.winter.av.temp)


#seed3  <- glmer(total.seeds~log.ros.area*trt + (1|year)+ (1|plot), data = subset(primula, total.seeds >0), family = "poisson")
```


###




Then the other miscellany we'll need (size independent parameters):

GOAL FOR 4/5: just make some these up for now and make a model that runs!
```{r}

#prob.flower.makes.seeds <- 0.73 #this is a made up number
## I need to change this because this is treatment dependent!
#no.seeds <- 36 #if you make seeds, this is on average how many seeds you make. But, this needs to be a function below
prob.seed.germ <- .022 #this is from the seed addition data - average seed has 0.022 chance of germination
prob.seedling.to.1leaf <- .1
prob.1leaf.to.1leaf <- .1
prob.1leaf.to.2leaf <- .1

#eventually this might change if we want treatment specific size of new recruits - will look into it more
new_sd <- sd(new.plants$log.ros.area)
new_mean <- mean(new.plants$log.ros.area)

```

Define the min and max size, which are the integration bounds of the IPM.
```{r size bounds, echo=T}
minRealsize <- min(primula$log.ros.area, na.rm=T) 

maxRealsize <- 1.1* max(primula$log.ros.area,na.rm=T)

#now add a new min & max size to keep the plants in for eviction
min.size <-minRealsize-1 #lower
max.size <-maxRealsize+1.5 #upper
```
## Collect model parameters into a vector

This is a little tricky! There are a lot of variables in the models, so be careful here with the equations for the mixed models
Also ~ how do deal with temperature in these?? Just add the variable in to get the slope??
I've just added in the mean temp, so these are specific to one specific temperature (in the future, I can write a loop to get a range of temperatures?)


```{r parameter vector, echo=FALSE}
#this is for range of climates
rows <- expand.grid(summer.mean.temp = seq(-2, 2, by = .5), grow.season.mean.temp = seq(-2, 2, by = .5),  winter.mean.temp = seq(-2, 2, by = .5), reproduction = c("veg","flowered"), trt = c("control", "drought", "irrigated"))

#this is per year
#row <- climate_scale %>% 
#  select(year, summer.tot.precip, summer.mean.temp, grow.season.mean.temp, winter.mean.temp)
#rows <- expand.grid(reproduction = c("veg","flowered"), trt = c("control", "drought", "irrigated"), year = seq(2016, 2023, by = 1))
#rows$year <- as.character(rows$year)
#rows <- full_join(row, rows)
#rows <- na.omit(rows)
#rows <- rows %>% mutate(temp = round(temp, 2))

#set up an empty parameter df
params=data.frame(
	growth.int = c(NA),
	growth.slope  = NA,
	growth.sd=NA,
	surv.int=NA,
	surv.slope=NA,
	pflow.int = NA,
	pflow.slope = NA,
	no.flow.int=NA,
	no.flow.slope=NA,
	recruit.size.mean=NA,
	recruit.size.sd=NA,
	prob.seed.germ = NA
)
params <- bind_cols(params, rows)
```

Stick all the parameters in. And use coefficients from the parametric bootstrap:
```{r parameters, echo=T}
#growth:
for (i in 1:nrow(params)) {
  if (params$reproduction[i] == "veg" && params$trt[i] == "control") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] + fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i]
  } else if (params$reproduction[i] == "flowered" && params$trt[i] == "control") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] + fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i] + fixef(gm.summer.av.temp.cor.trt.int6)[3]
  } else if (params$reproduction[i] == "veg" && params$trt[i] == "irrigated") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] + fixef(gm.summer.av.temp.cor.trt.int6)[5] + 
      fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i] +
      fixef(gm.summer.av.temp.cor.trt.int6)[9] * params$summer.mean.temp[i]
  } else if (params$reproduction[i] == "flowered" && params$trt[i] == "irrigated") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] +  fixef(gm.summer.av.temp.cor.trt.int6)[3] + fixef(gm.summer.av.temp.cor.trt.int6)[5] +
      fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i] +            fixef(gm.summer.av.temp.cor.trt.int6)[9] * params$summer.mean.temp[i]
  } else if (params$reproduction[i] == "veg" && params$trt[i] == "drought") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] +   fixef(gm.summer.av.temp.cor.trt.int6)[4] + 
      fixef(gm.summer.av.temp.cor.trt.int6)[8] * params$summer.mean.temp[i] + 
      fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i]
  } else if (params$reproduction[i] == "flowered" && params$trt[i] == "drought") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] + #intercept
      fixef(gm.summer.av.temp.cor.trt.int6)[3] + #pflower = 1 intercept
      fixef(gm.summer.av.temp.cor.trt.int6)[4] + #trt = drought int
      fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i] + fixef(gm.summer.av.temp.cor.trt.int6)[8] * params$summer.mean.temp[i]
  }
}

#slope for growth
params$growth.slope[params$reproduction == "veg"] <- fixef(gm.summer.av.temp.cor.trt.int6)[2]
params$growth.slope[params$reproduction == "flowered"]<- fixef(gm.summer.av.temp.cor.trt.int6)[2] + fixef(gm.summer.av.temp.cor.trt.int6)[7]

params$growth.sd <- growth_var[growth_var$grp=="Residual","sdcor"] # growth sd of residuals

#survival = sm.gs.av.temp
for (i in 1:nrow(params)) {
  params$surv.int[i] <- fixef(sm.gs.av.temp)[1] + fixef(sm.gs.av.temp)[3]*params$grow.season.mean.temp[i]
}
 # survival slope
params$surv.slope <- fixef(sm.gs.av.temp)[2] # survival size t

#pflower
for (i in 1:nrow(params)) {
  if (params$reproduction[i] == "veg") {
    params$pflow.int[i] <- fixef(fm.gs.av.temp.cor.int1)[1] + fixef(fm.gs.av.temp.cor.int1)[4] * params$grow.season.mean.temp[i]
  } else if (params$reproduction[i] == "flowered") {
    params$pflow.int[i] <- fixef(fm.gs.av.temp.cor.int1)[1] + fixef(fm.gs.av.temp.cor.int1)[4] * params$grow.season.mean.temp[i] + fixef(fm.gs.av.temp.cor.int1)[3]
  }
}

#slopes:
params$pflow.slope[params$reproduction == "veg"] <- fixef(fm.gs.av.temp.cor.int1)[2]
params$pflow.slope[params$reproduction == "flowered"]<- fixef(fm.gs.av.temp.cor.int1)[2] + fixef(fm.gs.av.temp.cor.int1)[5]


for (i in 1:nrow(params)) {
    params$no.flow.int[i] <- fixef(noflowers.winter.av.temp)[1] + fixef(noflowers.winter.av.temp)[3]*params$winter.mean.temp[i]
}

params$no.flow.slope <- fixef(noflowers.winter.av.temp)[2] # flower number production size t

#params$pdorm.int <-fixef(dorm_model)[1] #intercept of dormancy model to calculate prob of dormancy (not size dependent)
#note that the IPM doesn't use dormancy parameter or the dormancy model

#params$p.flower.makes.seed <- prob.flower.makes.seeds
#seed3  <- glmer(total.seeds~log.ros.area*trt + (1|year)+ (1|plot), data = subset(primula, total.seeds >0), family = "poisson")
# params$no.seeds.int[params$trt == "control"] <- fixef(seed3)[1]
# params$no.seeds.slope[params$trt == "control"] <- fixef(seed3)[2]
# 
# params$no.seeds.int[params$trt == "drought"] <- fixef(seed3)[1] + fixef(seed3)[4]
# params$no.seeds.slope[params$trt == "drought"] <- fixef(seed3)[2] + fixef(seed3)[6]
# 
# params$no.seeds.int[params$trt == "irrigated"] <- fixef(seed3)[1] + fixef(seed3)[3]
# params$no.seeds.slope[params$trt == "irrigated"] <- fixef(seed3)[2] + fixef(seed3)[5]

#currently, seeds per flower is not size dependent, but is treatment dependent
#flowers in drought plots make 6 seeds, control make 11, irrigated make 13
params$seeds[params$trt == "irrigated"] <- 13
params$seeds[params$trt == "drought"] <- 6
params$seeds[params$trt == "control"] <- 11

#params$no.seeds <- no.seeds
params$prob.seed.germ <- prob.seed.germ
params$recruit.size.mean <- new_mean # mean new >1 leaf plant size
params$recruit.size.sd<- new_sd # sd of new >1 leaf plant size
```

# Build the model!

### Step 1. Build vital rate functions (components of the kernel)

```{r VR functions}
###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
###         Load functions
###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#SURVIVAL AT SIZE X
s.x=function(x,params) {
	u=exp(params$surv.int+params$surv.slope*x)
	return(u/(1+u))
}

#how to test this: 
### run function for a plant of size 1 and for the first row of parameters
#s.x(x = 1, params = params[1,])
### run function for a plant of size 1 but for all rows of parameters (so get a list )
#s.x(x = 1, params = params)
#ok this works and seems to work for all rows of params. great.


# #note - in the final code, just use the correct eviction function and comment out (or delete the other [JL - 1/9 made the corrected eviction one name g.yx.A/S]
# g.yx.A<-function(xp,x,params){
#   xb=pmin(pmax(x,minRealsize),maxRealsize) #Transforms all values below/above limits in min/max size (floor & ceiling)
#   growth_to_newsize <-params$growth.int.A + params$growth.slope*xb
#   growth_sd <- params$growth.sd
#   return(dnorm(xp,mean=growth_to_newsize,sd=growth_sd))
# }


#GROWTH FROM SIZE X TO Y; 
  ## returns a *probability density distribution* for each x value
g.yx<-function(y,x,params){
    # eviction here...
  xb=pmin(pmax(x,minRealsize),maxRealsize) #Transforms all values below/above limits in min/max size (floor & ceiling)
  growth_to_newsize <-params$growth.int + params$growth.slope*xb
  growth_sd <- params$growth.sd
  return(dnorm(y,mean=growth_to_newsize,sd=growth_sd))
  #dnorm(y,mean=params$growth.int + params$growth.slope*x,sd=params$growth.sd)

}
#to test this:
###well actually, maybe I don't know what the end product is supposed to look like - and is y the size it grows to ve
#g.yx(y = 1, x = 1, params = params[1,])

#Tom Miller's combined s and g kernel
P <- function(y, x, params){
  s.x(x, params)*g.yx(y, x, params)
}



#PROBABILITY OF FLOWERING OF SIZE X individuals
pf.x <-function(x,params){
	u<-exp(params$pflow.int+params$pflow.slope*x)
	return(u/(1+u))
}
#testing this for a plant of size 5
#pf.x(x = 8,params = params)

# #PRODUCTION OF seedlings by X-SIZED plants that flowered the previous year
###Here i've put in the misc bits, but not sure if this is correct - seems ok for now

# f.yx.flowered=function(x,params) { 		
# 	return(pf.x.flowered(x,params)*
#     exp(params$no.flow.int+params$no.flow.slope*x)*
#     params$p.flower.makes.seed*
#     params$no.seeds* #this will eventually be a function??
#     params$prob.seed.germ)
#  #is this right? I want a number of seedlings that are made.
# }

f.yx=function(x,params) { 		
	#return(pf.x(x,params)*exp(params$no.flow.int+params$no.flow.slope*x)* exp(params$no.seeds.int+params$no.seeds.slope*x) *
  return(pf.x(x,params)*exp(params$no.flow.int+params$no.flow.slope*x)* params$seeds * params$prob.seed.germ)
}
##so this should be outputting the number of seedlings made? Yes
#f.yx(x = 5,params = params)

##do big plants make a million flowers?
#exp(params$no.flow.int+params$no.flow.slope*8) 
## no they make a reasonable amount


#SIZE DISTRIBUTION OF RECRUITS - so the ones going from the 1 leaf stage into the continuous stage. I'm not sure that this is doing what I want it to - 
recruit.size<-function(y,params){
    ## returns a *probability density distribution*
  dnorm(y,mean=params$recruit.size.mean,sd=params$recruit.size.sd)
}
```

```{r setting up stage matrices}
params_list <-  filter(params) %>% split(., seq(nrow(.))) #this splits up params into X rows, which I can feed into the function below

#params_in <- params_list[1] #to test it!
# BIGMATRIX ---------------------------------------------------------------
#building off of code from Tom Miller:
mat.size = 100 #dimensions of continuous matrix
bigmatrix<-function(params_list, mat.size)
  {
  n<-mat.size
  L<-min.size
  U<-max.size
  #these are the upper and lower integration limits
  h<-(U-L)/n                   #Bin size
  b<-L+c(0:n)*h;               #Lower boundaries of bins 
  y<-0.5*(b[1:n]+b[2:(n+1)]);  #Bins' midpoints
  #these are the boundary points (b) and mesh points (y)

  # Fertility matrix
  Fmat<-matrix(0,(n+2),(n+2))
  
  # top row: # seedlings produced by each size class:
  Fmat[1,3:(n+2)]<-f.yx(y,params_list) #This is a y because it is the fecundity kernel for plants that have already grown/survived, I think? It's what Tom has
  
  # Growth/survival transition matrix
  Tmat<-matrix(0,(n+2),(n+2))
  
  # probability seedling becomes a 1 leaf plant
  Tmat[2,1]<- prob.seedling.to.1leaf
  
   # probability 1 leaf plant stays as a 1 leaf plant
  Tmat[2,2]<- prob.1leaf.to.1leaf
  
  # Graduation from 1 leaf to cts size = prob 1 leaf becomes a 2 leaf * size dist of new 2 leafers
  Tmat[3:(n+2),2]<- prob.1leaf.to.2leaf *recruit.size(y,params_list) * h
  
  # Growth/survival transitions among cts sizes
  Tmat[3:(n+2),3:(n+2)]<- t(outer(y,y,P,params=params_list)) * h 
  
  # Put it all together
  IPMmat<-Fmat+Tmat     #Full Kernel is simply a summation of fertility and transition matrix
  out_matrix <- list(IPMmat=IPMmat,Fmat=Fmat,Tmat=Tmat,meshpts=y)
  
  out_lamb <- data.frame(lambda = lambda(IPMmat), summer.temp = params_list$summer.mean.temp,  gs.temp = params_list$grow.season.mean.temp, winter.temp = params_list$winter.mean.temp, reproduction = params_list$reproduction, trt = params_list$trt)
 # return(out_matrix) #can check this to have a list of all of the matrices listed above
  return(out_lamb) #for now, I just want lambdas
 # return(list(out_matrix = out_matrix, out_lamb = out_lamb))

}

#what I want returned is lambdas
lamb_lists <- lapply(X = params_list, FUN = bigmatrix, mat.size = mat.size) #for each row of params_list, run the big matrix function!
#great~! now make it a df
primula_lambda <- do.call(rbind, lamb_lists)
#write.csv(primula_lambda, "../tables/primula.climate.lambdas.2023.01.09.csv", row.names = F)


```

#just grab one of the matrices to see what's going on with the kernels
```{r}
save <- bigmatrix(params = params[10,], mat.size = mat.size)

#this is code that works for just one set of params
# primula_lambda <- bigmatrix(params = params_in,
#                             mat.size = mat.size)

popbio::image2(save$IPMmat)
image(save$Fmat,main='F kernel - control flowered')	
image(save$Tmat,main='S+G kernel - control flowered')	
abline(0,1,lwd=3)	
lambda(save$IPMmat)

IPMmat <- save$IPMmat

# Assuming save$IPMmat is a big matrix (e.g., 102 by 102)
IPMmat <- save$IPMmat

# Exclude the first two rows and columns
subset_matrix <- IPMmat[3:nrow(IPMmat), 3:ncol(IPMmat)]

# Create the image plot
image(
  1:(ncol(subset_matrix)),      # x-axis values
  1:(nrow(subset_matrix)),      # y-axis values
  subset_matrix,                # Matrix for z-axis values
  main = "IPM Matrix",          # Main title
  xlab = "Column Index",        # X-axis label
  ylab = "Row Index"            # Y-axis label
)

mtext("e)", side = 3, cex = 0.9, adj = 0, line = 0.1)


#for the full kernel, is the Fmat gettign swamped out by the Tmat?
# sometimes it's hard to see both the fecundity part of the kernel swamps the growth/survival part, so here's a plotting trick to level out the kernel
image2(save$IPMmat^.3,main='full kernel^0.3') #ok, that works!	but these kernels look weird (ie the t+1 side is flipped and has wrong scale...not sure how to fix that)

image.plot(save$IPMmat, xlab="Size (t)",ylab="Size (t+1)",
col=topo.colors(100), main="IPM matrix")

```
```{r}
#use this code to check and see how many seedlings are produced by each size class
matrix <- as.data.frame(save$IPMmat)
no.seedlings <- matrix[1,]
no.seedlings <- no.seedlings %>% pivot_longer(
    cols = starts_with("V"),
    values_to = "no.seedlings",
    names_to = "size",
    names_pattern = "V(.*)")
barplot(no.seedlings$no.seedlings, xlab = "Plant size (small to large)", ylab = "Number of seedlings produced")

#and use this code to see p(1 leaf becomes a 2 leaf)* size distribution of new individuals into kernel
new.cont <- matrix[3:102,2]
barplot(new.cont, ylab = "Prob. 1 leaf becomes >2 leaf * size distribution of new >2 leafs", xlab = "Plant size (small to large)")

```


```{r}
#Jenn's eviction from townsendia
P.A.checkevict=G.A 								# placeholder;redefine P on the next line
for(i in 1:n) P.A.checkevict[,i]=G.A[,i]  		# growth/survival kernel, where survival now =1
frac.evictA<-1-colSums(P.A.checkevict)



par(mfrow=c(1,1))
plot(frac.evictA~y, type="l", xaxt="n", col=colA, lwd=2,
     xlab="rosette area", ylab="proportion 'evicted'",
     ylim=c(0,0.1), las=1, cex.axis=0.8)
axis(side=1, at=log(c(0.1, 0.2,0.5,1,2,5,10,20,50,100,200)), labels=c(0.1, 0.2,0.5,1,2,5, 10,20, 50, 100,200), las=1, cex.axis=0.9)
lines(frac.evictS~y, type="l", col=colS, lwd=2)
```



```{r}
# #now to make a graph:
# 
ipm <- primula_lambda %>%
  ggplot(aes(x = precip, y = lambda, linetype = reproduction))+
  geom_line(data = subset(primula_lambda, temp == 8.14), aes(x = precip, y = lambda), color = "lightblue2",  size = 1.25)+
  geom_line(data = subset(primula_lambda, temp == 9.64), aes(x = precip, y = lambda), color = "darkgrey", size = 1.25)+
  geom_line(data = subset(primula_lambda, temp == 11.14), aes(x = precip, y = lambda), color = "firebrick", size = 1.25)+
  labs(x = "Growing Season Total Precipitation (mm)", y = "Lambda")+
  scale_linetype_manual(values=c("longdash", "solid"))+
  theme(legend.position="none")

ggplot(primula_lambda, aes(x = summer.temp, y = gs.temp, fill = lambda)) +
   geom_tile(color = "black") +
   scale_fill_gradient(low = "white", high = "red")
# 
# ggsave(plot = ipm, file = "C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/Figures/ipm climate.png", width = 5, height = 5, dpi = 300)

```

```{r}
#looking at lambdas per year:
primula_lambda %>% 
  ggplot(aes(x = year, y = lambda, color = trt, shape = reproduction))+
  geom_point(size = 2)+
    scale_color_manual(values = c("#E7B800", "#FC4E07", "#00AFBB"), name = "")+
  scale_shape_manual(values = c(1, 16))
#change reproduction to cost vs no cost
  

```

 
 


```{r}
#summer.precip changing while summer precip, sumer temp, etc does not
# sp <- primula_lambda %>% 
#   filter(near(summer.temp, 0, tol = .1)) %>% 
#   filter(near(gs.temp, 0, tol = .1)) %>% 
#   filter(near(winter.temp, 0, tol = .2)) %>% 
#   ggplot(aes(x = summer.precip, y = lambda, linetype = reproduction, color = trt))+
#   geom_line(linewidth = 1.5)+
#   scale_color_manual(values = c("#E7B800", "#FC4E07", "#00AFBB"), name = "")+
#   scale_linetype_manual(values = c("solid", "dashed"), labels = c("cost", "no cost"), name = "")+
#   labs(y = expression(paste("\u03BB")), x = "Summer Precipitation")
st <- primula_lambda %>% 
  #filter(near(summer.temp, 0, tol = .1)) %>% 
  filter(near(gs.temp, 0, tol = .1)) %>% 
  filter(near(winter.temp, 0, tol = .2)) %>% 
  ggplot(aes(x = summer.temp, y = lambda, linetype = reproduction, color = trt))+
  geom_line(linewidth = 1.5)+
  scale_color_manual(values = c(Z[3], Z[5], Z[1]), name = "")+
 scale_linetype_manual(values = c( "dashed","solid"), name = "")+
  labs(y = expression(paste("\u03BB")), x = "Summer Temperature")+
  scale_y_continuous(limits=c(.875,1))+ 
  theme(legend.position = "none")+
  geom_hline(yintercept = 1, color="grey", linetype="dashed", linewidth = 1.25)
gst <- primula_lambda %>% 
  filter(near(summer.temp, 0, tol = .1)) %>% 
  filter(near(winter.temp, 0, tol = .2)) %>% 
  ggplot(aes(x = gs.temp, y = lambda, linetype = reproduction, color = trt))+
  geom_line(linewidth = 1.5)+
  scale_color_manual(values = c(Z[3], Z[5], Z[1]), name = "")+
  scale_linetype_manual(values = c("dashed", "solid"), name = "")+
  labs(y = expression(paste("\u03BB")), x = "Spring Temperature")+
  scale_y_continuous(limits=c(.875,1))+
  geom_hline(yintercept = 1, color="grey", linetype="dashed", linewidth = 1.25)+ 
  theme(legend.position = "none")

wt <- primula_lambda %>% 
  filter(near(summer.temp, 0, tol = .1)) %>% 
  filter(near(gs.temp, 0, tol = .2)) %>% 
  ggplot(aes(x = winter.temp, y = lambda, linetype = reproduction, color = trt))+
  geom_line(linewidth = 1.5)+
  scale_color_manual(values = c(Z[3], Z[5], Z[1]), name = "")+
  scale_linetype_manual(values = c("dashed", "solid"), name = "")+
  labs(y = expression(paste("\u03BB")), x = "Winter Temperature")+
  scale_y_continuous(limits=c(.875,1))+ 
  theme(legend.position = "none")+
  geom_hline(yintercept = 1, color="grey", linetype="dashed", linewidth = 1.25)





ggsave(plot = st, file = "C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/Figures/IPM/1st.png", width = 5, height = 4, dpi = 300)
ggsave(plot = gst, file = "C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/Figures/IPM/1gst.png", width =5, height = 4, dpi = 300)
ggsave(plot = wt, file = "C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/Figures/IPM/1wt.png", width = 5, height = 4, dpi = 300)

```





```{r}
#this is the clunky way to do it!!

#growth kernels - separate for each IDE treatment
G.control=h*outer(y,y,g.yx.control,params=params) 	# growth kernel
image(y,y,t(G.control),main='growth kernel - control') # plot it

G.drought=h*outer(y,y,g.yx.drought,params=params) 	# growth kernel
image(y,y,t(G.drought),main='growth kernel - drought') # plot it

G.irr=h*outer(y,y,g.yx.irr,params=params) 	# growth kernel
image(y,y,t(G.irr),main='growth kernel - irrigated') # plot it

S=s.x(y,params=params) 				# survival 
plot(y,S,type='l',main='survival')	# plot it

P.control=G.control 									# placeholder;redefine P on the next line
for(i in 1:n) P.control[,i]=G.control[,i]*S[i]  		# growth/survival kernel
image(y,y,t(P.control),main='survival/growth kernel - control')	# plot it
abline(0,1,lwd=3)						# plot 1:1, which represents stasis

P.drought=G.drought									# placeholder;redefine P on the next line
for(i in 1:n) P.drought[,i]=G.drought[,i]*S[i]  		# growth/survival kernel
image(y,y,t(P.drought),main='survival/growth kernel - drought')	# plot it
abline(0,1,lwd=3)						# plot 1:1, which represents stasis

P.irr=G.irr								# placeholder;redefine P on the next line
for(i in 1:n) P.irr[,i]=G.irr[,i]*S[i]  		# growth/survival kernel
image(y,y,t(P.irr),main='survival/growth kernel - irrigated')	# plot it
abline(0,1,lwd=3)						# plot 1:1, which represents stasis



F.flower=h*outer(y,y,f.yx.flowered,params=params) 	# reproduction kernel
image(y,y,t(F.flower),main='fecundity kernel for plants that flowered previous year')	# plot it

F.veg=h*outer(y,y,f.yx.veg,params=params) 	# reproduction kernel
image(y,y,t(F.veg),main='fecundity kernel for plants that did not flower previous year')	# plot it
####

K.drought.flow=P.drought+F.flower 															# full kernel for 
image(y,y,t(K.drought.flow),main='full kernel - drought plants that flowered in year-1')			# plot it

K.drought.veg=P.drought+F.veg 															# full kernel for 
image(y,y,t(K.drought.veg),main='full kernel - drought plants that didnt flower in year-1')			# plot it

K.irr.flow=P.irr+F.flower 															# full kernel for 
image(y,y,t(K.irr.flow),main='full kernel - irr plants that flowered in year-1')			# plot it

K.irr.veg=P.irr+F.veg 															# full kernel for 
image(y,y,t(K.irr.veg),main='full kernel - irr plants that didnt flower in year-1')			# plot it

K.control.flow=P.control+F.flower 															# full kernel for 
image(y,y,t(K.control.flow),main='full kernel - control plants that flowered in year-1')			# plot it

K.control.veg=P.control+F.veg 															# full kernel for 
image(y,y,t(K.control.veg),main='full kernel - control plants that didnt flower in year-1')			# plot it

lambda(K.drought.flow)
lambda(K.drought.veg)
lambda(K.irr.flow)
lambda(K.irr.veg)
lambda(K.control.flow)
lambda(K.control.veg)


```
Ok! These run! Obviously some things are missing and will need to change, but at least I get some lambdas! 

What does it mean to compare lambda across these? Can we just think about fitness here??
Wait, why is lambda for ones that flowered in t-1 HIGHER than ones that didn't flower?????
That seems really weird...will think about it more
At least drought lambda is lower, although control and irrigated arent that different
