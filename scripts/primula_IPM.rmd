---
title: "primula_IPM"
author: "JL"
date: "3/2/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(AICcmodavg)
library(lme4)
library(popbio)
theme_set(theme_classic()) #for ggplot
```

- what do f.yx functions need to return? Just number of seedlings? so some thing like the pf functions?
- HOW to get stage matrices in there? No idea - not sure how Tom's code does it
Where I'm leaving it off: Tom's code has a n+2 type of deal, but I'm not sure how to actually get the components in...
-For the most part, I've just taken the average/made up the misc compoenents. Which is fine for now but eventually will need to be dealt with!



```{r}
### read in all years of Primula data and weather data from the Cowichan
# Add in climate data:
source("../scripts/Cowichan_climatevalues.R")

# Add in demography data:
source("../scripts/dode_allyears_cleaned.R")
#if this doesn't run, it's probably something weird with markdown - go into that R script and change the dormancy read.csv to have ".." instead of "." at the beginning

## Join climate data to demography data by year
primula <- left_join(Dodecatheon, climate, by = "year")

#remove(climate, Dodecatheon)
#gives a warning but I think it's fine!

new.plants <- primula %>%   
  mutate(leaves = if_else(year == 2022, no.smleaf + no.bigleaf, leaves)) %>% 
  filter(year == YrTag) %>% ##need to filter cases where year tagged == year (so newly tagged that year)
  filter(pflower == 0) %>% ## actual new plants definitely can't flower in the first year
  filter(leaves < 3) %>% 
  filter(!is.na(log.ros.area))
```




Eventually do to:
-add in image of life cycle diagram
- think more about climate variables - what if I switch to average temperature instead of min/max? To reduce number of models. Also, potentially could just look at spring/growing season climate (ie when the plants are out and growing)


##IPM for Primula data
```{r}
#load best fit models from primula_climate_VR.r"

gm17 <- lmer(log.ros.areaT1 ~ log.ros.area + trt * grow.season.mean.max.temp+ (1|plot) + (1|year), data = primula) ###
  growth_var <- as.data.frame(VarCorr(gm17)) #assumes same variance across all, not sure if thats ok
fm.f16 <- glmer(pflowerT1 ~ log.ros.area * as.factor(pflower) + grow.season.mean.max.temp+ (1|plot) + (1|year), data = primula, family = "binomial")
sm10lag <- glmer(psurvivalT1 ~ log.ros.area*grow.season.min.temp.1yearlag+ (1|plot) + (1|year), data = primula, family = "binomial") ###
noflow9 <- glm(flow.sum ~ log.ros.area + grow.season.mean.min.temp, data = subset(primula, flow.sum > 0), family = "poisson")
```


###




Then the other miscellany we'll need (size independent parameters):

GOAL FOR 4/5: just make some these up for now and make a model that runs!
```{r}
#I'm just throwing these in from the hookeri model - these arent right!!!
prob.flower.makes.seeds <- 0.73 #this is a made up number
no.seeds <- 80 #if you make seeds, this is how many seeds you make per capsule (so per capita?? does this need to be multiplied by number of capsules?) this is actually size dependent, I think - will need more work here.
prob.seed.germ <- .001 #made up, will change later (after seed addition data comes in )

#eventually this might change if we want treatment specific size of new recruits - will look into it more
new_sd <- sd(new.plants$log.ros.area)
new_mean <- mean(new.plants$log.ros.area)

```

Define the min and max size, which are the integration bounds of the IPM.
```{r size bounds, echo=T}
minRealsize <- min(primula$log.ros.area, na.rm=T) 

maxRealsize <- 1.1* max(primula$log.ros.area,na.rm=T)

#now add a new min & max size to keep the plants in for eviction
#note - this was code from Townsenia code - will need to revisit for Primula!
min.size <-minRealsize-1 #lower
max.size <-maxRealsize+1.5 #upper
```
## Collect model parameters into a vector

This is a little tricky! There are a lot of variables in the models, so be careful here with the equations for the mixed models
Also ~ how do deal with temperature in these?? Just add the variable in to get the slope??
I've just added in the mean temp, so these are specific to one specific temeperature (in the future, I think I can write a loop to get a range of temperatures?)


```{r parameter vector, echo=FALSE}
#whats the average growing season max temp? Eventually, will need to do a loop here for different climate variables...
av.grow.max.temp <- climate_percentiles$maxT_mean[1]
av.grow.min.temp <- climate_percentiles$minT_mean[1]


params=data.frame(
	growth.int.control = NA,
	growth.int.irr = NA,
	growth.int.drought = NA,
	growth.slope  = NA,
	#growth.slope.irr = NA,
	#growth.slope.drought = NA,
	growth.sd=NA,
	
	surv.int=NA,
	surv.slope=NA,

	pflow.int.flowered=NA,
	pflow.int.veg=NA,
	pflow.slope.flowered=NA,
	pflow.slope.veg=NA,
	
	no.flow.int=NA,
	no.flow.slope=NA,
	no.seeds.int=NA,
	no.seeds.slope=NA,
	
	recruit.size.mean=NA,
	recruit.size.sd=NA,
	
	p.flower.makes.seed=NA,
	no.seeds = NA,
	prob.seed.germ = NA
	#pdorm.int=NA
)
#things get messy here, check that these all make sense...[can add written out equations here...]
params$growth.int.control <- fixef(gm17)[1] + fixef(gm17)[5]*av.grow.max.temp # growth intercept for control
params$growth.int.drought <- fixef(gm17)[1] + fixef(gm17)[3] + fixef(gm17)[5]*av.grow.max.temp + fixef(gm17)[6]*av.grow.max.temp # growth intercept for drought
params$growth.int.irr <- fixef(gm17)[1] + fixef(gm17)[4] + fixef(gm17)[5]*av.grow.max.temp + fixef(gm17)[7]*av.grow.max.temp# growth intercept for irr

#because temp is constant here, no need for varying slopes! they are all the same (for now...)
params$growth.slope <- fixef(gm17)[2] # growth slope size t for control
#params$growth.slope.irr <- fixef(growth_model)[2] # growth slope size t for irrigation
#params$growth.slope.drought <- fixef(growth_model)[2] # growth slope size for drought
params$growth.sd <- growth_var[growth_var$grp=="Residual","sdcor"] # growth sd of residuals

params$surv.int <- fixef(sm10lag)[1] + fixef(sm10lag)[3]*av.grow.min.temp # survival intercept
params$surv.slope <- fixef(sm10lag)[2] + fixef(sm10lag)[4]*av.grow.min.temp # survival size t

params$pflow.int.veg <- fixef(fm.f16)[1] + fixef(fm.f16)[4]*av.grow.max.temp # probability of flowering intercept for pflower == 0
params$pflow.int.flowered <- fixef(fm.f16)[1] + fixef(fm.f16)[3] + fixef(fm.f16)[4]*av.grow.max.temp # probability of flowering intercept
params$pflow.slope.veg <- fixef(fm.f16)[2] # probability of flowering slope for veg plants
params$pflow.slope.flowered <- fixef(fm.f16)[2] + fixef(fm.f16)[5] # probability of flowering slope for flowered plants

params$no.flow.int <- coef(noflow9)[1] + coef(noflow9)[3]*av.grow.min.temp # flower number production intercept at certain temp
params$no.flow.slope <- coef(noflow9)[2] # flower number production size t

#params$pdorm.int <-fixef(dorm_model)[1] #intercept of dormancy model to calculate prob of dormancy (not size dependent)
#note that the IPM doesn't use dormancy parameter or the dormancy model

params$p.flower.makes.seed <- prob.flower.makes.seeds
params$no.seeds <- no.seeds
params$prob.seed.germ <- prob.seed.germ
params$recruit.size.mean <- new_mean # mean new >1 leaf plant size
params$recruit.size.sd<- new_sd # sd of new >1 leaf plant size

```

# Build the model!

### Step 1. Build vital rate functions (components of the kernel)

```{r VR functions}
###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
###         Load functions
###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#SURVIVAL AT SIZE X
s.x=function(x,params) {
	u=exp(params$surv.int+params$surv.slope*x)
	return(u/(1+u))
    }

#GROWTH FROM SIZE X TO XP for CONTROL
#this includes the eviction solution from townsendia, not sure how this will work for primula
g.yx.control<-function(xp,x,params){
  xb=pmin(pmax(x,minRealsize),maxRealsize) #Transforms all values below/above limits in min/max size (floor & ceiling)
  growth_to_newsize <-params$growth.int.control + params$growth.slope*xb
  growth_sd <- params$growth.sd
  return(dnorm(xp,mean=growth_to_newsize,sd=growth_sd))
}

#GROWTH FROM SIZE X TO Y for DROUGHT
g.yx.drought<-function(xp,x,params){
  xb=pmin(pmax(x,minRealsize),maxRealsize) #Transforms all values below/above limits in min/max size (floor & ceiling)
  growth_to_newsize <-params$growth.int.drought + params$growth.slope*xb
  growth_sd <- params$growth.sd
  return(dnorm(xp,mean=growth_to_newsize,sd=growth_sd))
}
#GROWTH FROM SIZE X TO Y for IRRIGATED
g.yx.irr<-function(xp,x,params){
  xb=pmin(pmax(x,minRealsize),maxRealsize) #Transforms all values below/above limits in min/max size (floor & ceiling)
  growth_to_newsize <-params$growth.int.irr + params$growth.slope*xb
  growth_sd <- params$growth.sd
  return(dnorm(xp,mean=growth_to_newsize,sd=growth_sd))
}


#PROBABILITY OF FLOWERING OF SIZE X individuals that flowered:
pf.x.flowered <-function(x,params){
	u<-exp(params$pflow.int.flowered+params$pflow.slope.flowered*x)
	return(u/(1+u));
	}
#PROBABILITY OF FLOWERING OF SIZE X individuals that did not flower:
pf.x.veg <-function(x,params){
	u<-exp(params$pflow.int.veg+params$pflow.slope.veg*x)
	return(u/(1+u));
}


# #PRODUCTION OF Y-SIZED INDIVIDUALS FROM X-SIZED MOMS that flowered the previous year
###Here i've put in the misc bits, but not sure if this is correct - seems ok for now
### this needs some work...
f.yx.flowered=function(xp,x,params) { 		
	pf.x.flowered(x,params)*
    exp(params$no.flow.int+params$no.flow.slope*x)*
    params$p.flower.makes.seed*
    params$no.seeds* #this will eventually be a function??
    params$prob.seed.germ
  return() #
}
f.yx.veg=function(xp,x,params) { 		
	pf.x.veg(x,params)*
    exp(params$no.flow.int+params$no.flow.slope*x)*
    params$p.flower.makes.seed*params$no.seeds*params$prob.seed.germ
  return() #not sure what this should be
}

#SIZE DISTRIBUTION OF RECRUITS - separate function (before was part of f.yx)
recruit.size<-function(xp,params){
  dnorm(xp,mean=params$recruit.size.mean,sd=params$recruit.size.sd)
}
#these return a size distribution of new recruits - I think this is not what I want because my fecundity kernel is feeding into a stage (what I need is the number of seedlings created by each size bin)
```

```{r setting up stage matrices}
#building off of code by Tom Miller:
# BIGMATRIX ---------------------------------------------------------------
bigmatrix<-function(params,
                   # lower.extension = 0, ## I'll need to extend lower and upper beyond true size limits
                    #upper.extension = 0,
                    mat.size, ## matrix dimensions
                    ){
  
  n<-mat.size
  L<-params$min.size + lower.extension
  U<-params$max.size + upper.extension
  #these are the upper and lower integration limits
  h<-(U-L)/n                   #Bin size
  b<-L+c(0:n)*h;               #Lower boundaries of bins 
  y<-0.5*(b[1:n]+b[2:(n+1)]);  #Bins' midpoints
  #these are the boundary points (b) and mesh points (y)
  #number of cells in the discretized kernel
  n=100

  # boundary points (the edges of the cells defining the kernel)
  b=min.size+c(0:n)*(max.size-min.size)/n 
  # mesh points (midpoints of the cells)
  y=0.5*(b[1:n]+b[2:(n+1)])
  # width of the cells
  h=y[2]-y[1]


  }

# Fertility matrix
Fmat<-matrix(0,(n+2),(n+2))
  
  # 1-yo banked seeds go in top row
mat[1,3:(n+2)]<-fx(y,params,rfx,PC1,PC2,PC3,extrap)
  
  # Growth/survival transition matrix
  Tmat<-matrix(0,(n+2),(n+2))
  
  # Graduation to 2-yo seed bank = pr(not germinating as 1-yo)
  Tmat[2,1]<-(1-params$germ1)
  
  # Graduation from 1-yo bank to cts size = germination * size distn * pre-census survival
  Tmat[3:(n+2),1]<- params$germ1 * params$precenus_surv * recruit.size(y,params) * h   
  
  # Graduation from 2-yo bank to cts size = germination * size distn * pre-census survival
  Tmat[3:(n+2),2]<- params$germ2 * params$precenus_surv * recruit.size(y,params) * h  
  
  # Growth/survival transitions among cts sizes
  Tmat[3:(n+2),3:(n+2)]<-t(outer(y,y,pxy,params=params,rfx=rfx,PC1=PC1,PC2=PC2,PC3=PC3,extrap=extrap)) * h 
  
  # Put it all together
  IPMmat<-Fmat+Tmat     #Full Kernel is simply a summation ot fertility
  #and transition matrix
  return(list(IPMmat=IPMmat,Fmat=Fmat,Tmat=Tmat,meshpts=y))
}
```


Ok, make the kernels!
```{r}

```

```{r}
#growth kernels - separate for each IDE treatment
G.control=h*outer(y,y,g.yx.control,params=params) 	# growth kernel
image(y,y,t(G.control),main='growth kernel - control') # plot it

G.drought=h*outer(y,y,g.yx.drought,params=params) 	# growth kernel
image(y,y,t(G.drought),main='growth kernel - drought') # plot it

G.irr=h*outer(y,y,g.yx.irr,params=params) 	# growth kernel
image(y,y,t(G.irr),main='growth kernel - irrigated') # plot it

S=s.x(y,params=params) 				# survival 
plot(y,S,type='l',main='survival')	# plot it

P.control=G.control 									# placeholder;redefine P on the next line
for(i in 1:n) P.control[,i]=G.control[,i]*S[i]  		# growth/survival kernel
image(y,y,t(P.control),main='survival/growth kernel - control')	# plot it
abline(0,1,lwd=3)						# plot 1:1, which represents stasis

P.drought=G.drought									# placeholder;redefine P on the next line
for(i in 1:n) P.drought[,i]=G.drought[,i]*S[i]  		# growth/survival kernel
image(y,y,t(P.drought),main='survival/growth kernel - drought')	# plot it
abline(0,1,lwd=3)						# plot 1:1, which represents stasis

P.irr=G.irr								# placeholder;redefine P on the next line
for(i in 1:n) P.irr[,i]=G.irr[,i]*S[i]  		# growth/survival kernel
image(y,y,t(P.irr),main='survival/growth kernel - irrigated')	# plot it
abline(0,1,lwd=3)						# plot 1:1, which represents stasis



F.flower=h*outer(y,y,f.yx.flowered,params=params) 	# reproduction kernel
image(y,y,t(F.flower),main='fecundity kernel for plants that flowered previous year')	# plot it

F.veg=h*outer(y,y,f.yx.veg,params=params) 	# reproduction kernel
image(y,y,t(F.veg),main='fecundity kernel for plants that did not flower previous year')	# plot it
####

K.drought.flow=P.drought+F.flower 															# full kernel for 
image(y,y,t(K.drought.flow),main='full kernel - drought plants that flowered in year-1')			# plot it

K.drought.veg=P.drought+F.veg 															# full kernel for 
image(y,y,t(K.drought.veg),main='full kernel - drought plants that didnt flower in year-1')			# plot it

K.irr.flow=P.irr+F.flower 															# full kernel for 
image(y,y,t(K.irr.flow),main='full kernel - irr plants that flowered in year-1')			# plot it

K.irr.veg=P.irr+F.veg 															# full kernel for 
image(y,y,t(K.irr.veg),main='full kernel - irr plants that didnt flower in year-1')			# plot it

K.control.flow=P.control+F.flower 															# full kernel for 
image(y,y,t(K.control.flow),main='full kernel - control plants that flowered in year-1')			# plot it

K.control.veg=P.control+F.veg 															# full kernel for 
image(y,y,t(K.control.veg),main='full kernel - control plants that didnt flower in year-1')			# plot it

lambda(K.drought.flow)
lambda(K.drought.veg)
lambda(K.irr.flow)
lambda(K.irr.veg)
lambda(K.control.flow)
lambda(K.control.veg)


```
Ok! These run! Obviously some things are missing and will need to change, but at least I get some lambdas! 

What does it mean to compare lambda across these? Can we just think about fitness here??
Wait, why is lambda for ones that flowered in t-1 HIGHER than ones that didn't flower?????
That seems really weird...will think about it more
At least drought lambda is lower, although control and irrigated arent that different
