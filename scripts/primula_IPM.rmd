---
title: "primula_IPM"
author: "JL"
date: "3/2/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(AICcmodavg)
library(lme4)
library(popbio)
theme_set(theme_classic()) #for ggplot
library(wesanderson) # for colors
Z <- wes_palettes$Zissou1

```

```{r}
### read in all years of Primula data and weather data from the Cowichan
# Add in climate data:
source("../scripts/Cowichan_climatevalues.R")

# Add in demography data:
# Add in demography data:
source("../scripts/dode_allyears_cleaned.R")

## Join climate data to demography data by year
primula <- left_join(Dodecatheon, climate_scale, by = "year") %>%
  mutate(pflower = as.factor(pflower),
         pflowerT1 = as.factor(pflowerT1),
         psurvivalT1 = as.factor(psurvivalT1))

remove(climate, climate_scale, Dodecatheon)

#these are for the new plants - we wren't consistent with what we called a new adult
new.plants <- primula %>%   
  mutate(leaves = if_else(year == 2022, no.smleaf + no.bigleaf, leaves)) %>% 
  filter(year == YrTag) %>% ##need to filter cases where year tagged == year (so newly tagged that year)
  filter(pflower == 0) %>% ## actual new plants definitely can't flower in the first year
  filter(leaves < 3) %>% ## can't have more than 3 leaves
  filter(!is.na(log.ros.area))
```

I thought a lot here about parametric versus non parametric bootstrapping - I'm going with parametric because it seems easier, and we are running models that we have confidence in. Also we won't have the convergence problem that we had with the townsendia bootstrapped data (some bootstrapped data samples lead to models that wouldnt converge). It is also easier to code!

##IPM for Primula data
```{r}
# set number of bootstrap samples:
boot = 10

#set seed so we have the same parameters each time
set.seed(12345)

###
fm.gs.av.temp.cor.int1 <- glmer(pflowerT1 ~ log.ros.area*pflower + grow.season.mean.temp + (1|plot) + (1|year), data = primula, family = "binomial")
#parametric bootstrap
#make matrix of random draws
pflower_samp = MASS::mvrnorm(n=boot, mu=fixef(fm.gs.av.temp.cor.int1), Sigma=vcov(fm.gs.av.temp.cor.int1))
pflower_samp
apply(pflower_samp,2,mean) #double check that the means are similar to fixef
fixef(fm.gs.av.temp.cor.int1)

####
sm.gs.av.temp <- glmer(psurvivalT1 ~ log.ros.area + grow.season.mean.temp + (1|plot) + (1|year), data = primula, family = "binomial")
#parametric bootstrap
#make matrix of random draws
psurv_samp = MASS::mvrnorm(n=boot, mu=fixef(sm.gs.av.temp), Sigma=vcov(sm.gs.av.temp))
psurv_samp
apply(psurv_samp,2,mean) #double check that the means are similar to fixef
fixef(sm.gs.av.temp)
###

gm.summer.av.temp.cor.trt.int6 <- lmer(log.ros.areaT1 ~ log.ros.area*pflower + trt*summer.mean.temp + (1|plot) + (1|year), data = primula, REML = F)
#parametric bootstrap
#make matrix of random draws
grow_samp = MASS::mvrnorm(n=boot, mu=fixef(gm.summer.av.temp.cor.trt.int6), Sigma=vcov(gm.summer.av.temp.cor.trt.int6))
grow_samp
apply(grow_samp,2,mean) #double check that the means are similar to fixef
fixef(gm.summer.av.temp.cor.trt.int6)

#variance for growth:
growth_var <- as.data.frame(VarCorr(gm.summer.av.temp.cor.trt.int6)) #assumes same variance across all
###

noflowers.winter.av.temp <- glmer(flow.sumT1 ~ log.ros.area + winter.mean.temp + (1|plot) + (1|year), data = subset(primula, flow.sumT1 > 0), family = "poisson")
#parametric bootstrap
#make matrix of random draws
noflowers_samp = MASS::mvrnorm(n=boot, mu=fixef(noflowers.winter.av.temp), Sigma=vcov(noflowers.winter.av.temp))
noflowers_samp
apply(noflowers_samp,2,mean) #double check that the means are similar to fixef
fixef(noflowers.winter.av.temp)


#seed3  <- glmer(total.seeds~log.ros.area*trt + (1|year)+ (1|plot), data = subset(primula, total.seeds >0), family = "poisson")
```


###

Then the other miscellany we'll need (size independent parameters):
```{r}
## I need to change this because this is treatment dependent!
#no.seeds <- 36 #if you make seeds, this is on average how many seeds you make. But, this needs to be a function below
prob.seed.germ <- .022 #this is from the seed addition data - average seed has 0.022 chance of germination
prob.seedling.to.1leaf <- .1
prob.1leaf.to.1leaf <- .1
prob.1leaf.to.2leaf <- .1

#eventually this might change if we want treatment specific size of new recruits - will look into it more
new_sd <- sd(new.plants$log.ros.area)
new_mean <- mean(new.plants$log.ros.area)

#Define the min and max size, which are the integration bounds of the IPM.
minRealsize <- min(primula$log.ros.area, na.rm=T) 
maxRealsize <- 1.1* max(primula$log.ros.area,na.rm=T)

#now add a new min & max size to keep the plants in for eviction
min.size <-minRealsize-1 #lower
max.size <-maxRealsize+1.5 #upper

```

## Collect model parameters into a vector

This is a little tricky! There are a lot of variables in the models, so be careful here with the equations for the mixed models

These are for the ipm without the bootstrap
```{r parameters without boot, echo=FALSE}
#this is for range of climates
rows <- expand.grid(summer.mean.temp = seq(-2, 2, by = .5), grow.season.mean.temp = seq(-2, 2, by = .5),  winter.mean.temp = seq(-2, 2, by = .5), reproduction = c("veg","flowered"), trt = c("control", "drought", "irrigated"))

#rows <- expand.grid(summer.mean.temp = 0, grow.season.mean.temp = 0,  winter.mean.temp = 0, reproduction = c("veg","flowered"), trt = c("control", "drought", "irrigated"))

#this is per year
#row <- climate_scale %>% 
#  select(year, summer.tot.precip, summer.mean.temp, grow.season.mean.temp, winter.mean.temp)
#rows <- expand.grid(reproduction = c("veg","flowered"), trt = c("control", "drought", "irrigated"), year = seq(2016, 2023, by = 1))
#rows$year <- as.character(rows$year)
#rows <- full_join(row, rows)
#rows <- na.omit(rows)
#rows <- rows %>% mutate(temp = round(temp, 2))

#set up an empty parameter df
params=data.frame(
	growth.int = c(NA),
	growth.slope  = NA,
	growth.sd=NA,
	surv.int=NA,
	surv.slope=NA,
	pflow.int = NA,
	pflow.slope = NA,
	no.flow.int=NA,
	no.flow.slope=NA,
	recruit.size.mean=NA,
	recruit.size.sd=NA,
	prob.seed.germ = NA
)
params <- bind_cols(params, rows)
```

Stick all the parameters in. And use coefficients from the parametric bootstrap:
```{r bootstrapped parameters}
###
summer.mean.temp = expand_grid(summer.mean.temp = seq(-2, 2, by = 1))
#growth intercept:
# data frame to store the results
growth.int <- data.frame(
  growth.int = numeric(6 * boot * nrow(summer.mean.temp)),
  summer.mean.temp = numeric(6 * boot * nrow(summer.mean.temp)),
  reproduction = character(6 * boot * nrow(summer.mean.temp)),
  trt = character(6 * boot * nrow(summer.mean.temp)),
  boot.group = numeric(6 * boot * nrow(summer.mean.temp))
)

# Counter to keep track of the row index
row_index <- 1

# Outer loop - for bootstrapped coefficients
for (j in 1:boot) {
  # Inner loop - for temperature values
  for (i in 1:nrow(summer.mean.temp)) {
    # Fill for veg control
    growth.int[row_index, "growth.int"] <- grow_samp[j,1] + grow_samp[j,6]*summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "summer.mean.temp"] <- summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "reproduction"] <- "veg"
    growth.int[row_index, "trt"] <- "control"
    growth.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index

    
    # Increment the row index
    row_index <- row_index + 1
    
    # Fill for flowered control
    growth.int[row_index, "growth.int"] <- grow_samp[j,1] + grow_samp[j,6]*summer.mean.temp$summer.mean.temp[i] + grow_samp[j,3]
    growth.int[row_index, "summer.mean.temp"] <- summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "reproduction"] <- "flowered"
    growth.int[row_index, "trt"] <- "control"
        growth.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index

    
    # Increment the row index
    row_index <- row_index + 1
    
    # Fill for veg irrigated
    growth.int[row_index, "growth.int"] <- grow_samp[j,1] + grow_samp[j,5] + grow_samp[j,6]*summer.mean.temp$summer.mean.temp[i] + grow_samp[j,9]*summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "summer.mean.temp"] <- summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "reproduction"] <- "veg"
    growth.int[row_index, "trt"] <- "irrigated"
        growth.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index

    
    # Increment the row index
    row_index <- row_index + 1
    
    # Fill for flow irrigated
    growth.int[row_index, "growth.int"] <- grow_samp[j,1] + grow_samp[j,3] + grow_samp[j,5] + grow_samp[j,6]*summer.mean.temp$summer.mean.temp[i] + grow_samp[j,9]*summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "summer.mean.temp"] <- summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "reproduction"] <- "flowered"
    growth.int[row_index, "trt"] <- "irrigated"
        growth.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index

    
    # Increment the row index
    row_index <- row_index + 1
        
    # Fill for veg drought
    growth.int[row_index, "growth.int"] <- grow_samp[j,1] + grow_samp[j,4] + grow_samp[j,8]*summer.mean.temp$summer.mean.temp[i] + grow_samp[j,6]*summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "summer.mean.temp"] <- summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "reproduction"] <- "veg"
    growth.int[row_index, "trt"] <- "drought"
        growth.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index

    
    # Increment the row index
    row_index <- row_index + 1
    
    # Fill for flow drought
    growth.int[row_index, "growth.int"] <- grow_samp[j,1] + 
      grow_samp[j,3] +
      grow_samp[j,4] + 
      grow_samp[j,8]*summer.mean.temp$summer.mean.temp[i] + 
      grow_samp[j,6]*summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "summer.mean.temp"] <- summer.mean.temp$summer.mean.temp[i]
    growth.int[row_index, "reproduction"] <- "flowered"
    growth.int[row_index, "trt"] <- "drought"
        growth.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index

    
    # Increment the row index
    row_index <- row_index + 1
  }
}

# 
# for (i in 1:nrow(summer.mean.temp)) {
#   temp_df_veg_control <- data.frame(
#     growth.int = grow_samp[,1] + grow_samp[,6]*summer.mean.temp$summer.mean.temp[i],
#     summer.mean.temp = summer.mean.temp$summer.mean.temp[i],
#     reproduction = "veg",
#     trt = "control"
#   )
#   temp_df_flow_control <- data.frame(
#     growth.int = grow_samp[,1] + grow_samp[,6]*summer.mean.temp$summer.mean.temp[i] + grow_samp[,3],
#     summer.mean.temp = summer.mean.temp$summer.mean.temp[i],
#     reproduction = "flowered",
#     trt = "control" 
#   )
#   temp_df_veg_irrigated <- data.frame(
#     growth.int = grow_samp[,1] + grow_samp[,5] + grow_samp[,6]*summer.mean.temp$summer.mean.temp[i] + grow_samp[,9]*summer.mean.temp$summer.mean.temp[i],
#     summer.mean.temp = summer.mean.temp$summer.mean.temp[i],
#     reproduction = "veg",
#     trt = "irrigated" 
#   )
#     temp_df_flowered_irrigated <- data.frame(
#     growth.int = grow_samp[,1] + grow_samp[,3] + grow_samp[,5] + grow_samp[,6]*summer.mean.temp$summer.mean.temp[i] + grow_samp[,9]*summer.mean.temp$summer.mean.temp[i],
#     summer.mean.temp = summer.mean.temp$summer.mean.temp[i],
#     reproduction = "flowered",
#     trt = "irrigated" 
#   )
#      temp_df_veg_drought <- data.frame(
#     growth.int = grow_samp[,1] + grow_samp[,4] + grow_samp[,8]*summer.mean.temp$summer.mean.temp[i] + grow_samp[,6]*summer.mean.temp$summer.mean.temp[i],
#     summer.mean.temp = summer.mean.temp$summer.mean.temp[i],
#     reproduction = "veg",
#     trt = "drought" 
#   )
#      temp_df_flowered_drought <- data.frame(
#     growth.int = grow_samp[,1] + 
#       grow_samp[,3] +
#       grow_samp[,4] + 
#       grow_samp[,8]*summer.mean.temp$summer.mean.temp[i] + 
#       grow_samp[,6]*summer.mean.temp$summer.mean.temp[i],
#     summer.mean.temp = summer.mean.temp$summer.mean.temp[i],
#     reproduction = "flowered",
#     trt = "drought" 
#   )
#     growth.int<- rbind(growth.int, temp_df_veg_control, temp_df_flow_control, temp_df_flowered_drought, temp_df_veg_drought, temp_df_flowered_irrigated, temp_df_veg_irrigated)
#     remove(temp_df_veg_control, temp_df_flow_control, temp_df_flowered_drought, temp_df_veg_drought, temp_df_flowered_irrigated, temp_df_veg_irrigated)
# }

#growth slope
growth.slope <- data.frame(
  growth.slope = c(grow_samp[, 2] + grow_samp[, 7], grow_samp[, 2]),
  reproduction = c(rep("flowered", nrow(grow_samp)), rep("veg", nrow(grow_samp))),
  boot.group = c(rep(1:nrow(grow_samp)), rep(1:nrow(grow_samp)))
)


growth <- left_join(growth.int, growth.slope)

##################################
#survival boot
grow.season.mean.temp = expand_grid(grow.season.mean.temp = seq(-2, 2, by = 1))

surv.slope <- data.frame(surv.slope = psurv_samp[, 2], boot.group = seq(1, boot, by = 1))

surv.int <- data.frame()
row_index <- 1

# Outer loop - for bootstrapped coefficients
for (j in 1:boot) {
  # Inner loop - for temperature values
  for (i in 1:nrow(grow.season.mean.temp)) {
    # Fill for veg control
    surv.int[row_index, "surv.int"] <-  psurv_samp[j, 1] + psurv_samp[j, 3] * grow.season.mean.temp$grow.season.mean.temp[i]
    surv.int[row_index, "grow.season.mean.temp"] <- grow.season.mean.temp$grow.season.mean.temp[i]
    surv.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index
   # Increment the row index
    row_index <- row_index + 1
}}

surv <-left_join(surv.int, surv.slope)

###
#####################
#slopes:

pflow.slope <- rbind(
  data.frame(pflow.slope = pflower_samp[,2], reproduction = "veg", boot.group = rep(1:nrow(grow_samp))),
  data.frame(pflow.slope = pflower_samp[,2] + pflower_samp[,5], reproduction = "flowered", boot.group = rep(1:nrow(grow_samp)))
  
)
#intercepts:
pflow.int <- data.frame()

row_index <- 1

# Outer loop - for bootstrapped coefficients
for (j in 1:boot) {
  # Inner loop - for temperature values
  for (i in 1:nrow(grow.season.mean.temp)) {
    # Fill for veg 
    pflow.int[row_index, "pflow.int"] <-  pflower_samp[j, 1] + pflower_samp[j, 4] * grow.season.mean.temp$grow.season.mean.temp[i]
    pflow.int[row_index, "grow.season.mean.temp"] <- grow.season.mean.temp$grow.season.mean.temp[i]
    pflow.int[row_index, "reproduction"] <- "veg"
    pflow.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index
   # Increment the row index
    row_index <- row_index + 1
    
    # Fill for flowered
    pflow.int[row_index, "pflow.int"] <-  pflower_samp[j, 1] + pflower_samp[j, 4] * grow.season.mean.temp$grow.season.mean.temp[i] + pflower_samp[j, 3]
    pflow.int[row_index, "grow.season.mean.temp"] <- grow.season.mean.temp$grow.season.mean.temp[i]
    pflow.int[row_index, "reproduction"] <- "flowered"
    pflow.int[row_index, "boot.group"] <- j  # Add the bootstrapped group index
   # Increment the row index
    row_index <- row_index + 1
  }
  }

# for (i in 1:nrow(grow.season.mean.temp)) {
#   temp_df_veg <- data.frame(
#     pflow.int = pflower_samp[, 1] + pflower_samp[, 4] * grow.season.mean.temp$grow.season.mean.temp[i],
#     grow.season.mean.temp = grow.season.mean.temp$grow.season.mean.temp[i],
#     reproduction = "veg",
#     boot.group = rep(i, nrow(pflower_samp))
# 
#   )
#   
#   temp_df_rep <- data.frame(
#     pflow.int = pflower_samp[, 1] + pflower_samp[, 4] * grow.season.mean.temp$grow.season.mean.temp[i] + pflower_samp[, 3],
#     grow.season.mean.temp = grow.season.mean.temp$grow.season.mean.temp[i],
#     reproduction = "flowered",
#     boot.group = rep(i, nrow(pflower_samp))
#   )
# 
#   pflow.int<- rbind(pflow.int, temp_df_veg, temp_df_rep)
# }

pflow <- left_join(pflow.int, pflow.slope)

###############################################################
#boot
winter.mean.temp = expand_grid(winter.mean.temp = seq(-2, 2, by = 1))

no.flow.slope <- data.frame(no.flow.slope = noflowers_samp[, 2], boot.group = seq(1, boot, by = 1))

no.flow.int <- data.frame()
row_index <- 1

# Outer loop - for bootstrapped coefficients
for (j in 1:boot) {
  # Inner loop - for temperature values
  for (i in 1:nrow(winter.mean.temp)) {
    no.flow.int[row_index, "no.flow.int"] <-  noflowers_samp[j, 1] + noflowers_samp[j, 3] * winter.mean.temp$winter.mean.temp[i]
    no.flow.int[row_index, "winter.mean.temp"] <- winter.mean.temp$winter.mean.temp[i]
    no.flow.int[row_index, "boot.group"] <- j  # Add the bootstrapped group indexj
   # Increment the row index
    row_index <- row_index + 1
}}

# no.flow.int <- data.frame()
# for (i in 1:nrow(winter.mean.temp)) {
#   temp_df <- data.frame(
#     no.flow.int = noflowers_samp[, 1] + noflowers_samp[, 3] * winter.mean.temp$winter.mean.temp[i],
#     winter.mean.temp = winter.mean.temp$winter.mean.temp[i],
#     boot.group = rep(i, nrow(noflowers_samp))
#   )
#   no.flow.int <- rbind(no.flow.int, temp_df)
# }

no.flow <- left_join(no.flow.slope, no.flow.int)


##stick these into one df
boot.params <- left_join(surv, no.flow)
boot.params <- left_join(boot.params, growth)
boot.params <- left_join(boot.params, pflow)


#Ok great, this looks like it works!

#####

#currently, seeds per flower is not size dependent, but is treatment dependent
#flowers in drought plots make 6 seeds, control make 11, irrigated make 13
boot.params$seeds[boot.params$trt == "irrigated"] <- 13
boot.params$seeds[boot.params$trt == "drought"] <- 6
boot.params$seeds[boot.params$trt == "control"] <- 11

#params$no.seeds <- no.seeds
boot.params$prob.seed.germ <- prob.seed.germ
boot.params$recruit.size.mean <- new_mean # mean new >1 leaf plant size
boot.params$recruit.size.sd<- new_sd # sd of new >1 leaf plant size

boot.params$growth.sd <- growth_var[growth_var$grp=="Residual","sdcor"] # growth sd of residuals


```



```{r original parameters, echo=T}
#growth:
for (i in 1:nrow(params)) {
  if (params$reproduction[i] == "veg" && params$trt[i] == "control") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] + fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i]
  } else if (params$reproduction[i] == "flowered" && params$trt[i] == "control") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] + fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i] + fixef(gm.summer.av.temp.cor.trt.int6)[3]
  } else if (params$reproduction[i] == "veg" && params$trt[i] == "irrigated") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] + fixef(gm.summer.av.temp.cor.trt.int6)[5] + 
      fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i] +
      fixef(gm.summer.av.temp.cor.trt.int6)[9] * params$summer.mean.temp[i]
  } else if (params$reproduction[i] == "flowered" && params$trt[i] == "irrigated") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] +  fixef(gm.summer.av.temp.cor.trt.int6)[3] + fixef(gm.summer.av.temp.cor.trt.int6)[5] +
      fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i] +            fixef(gm.summer.av.temp.cor.trt.int6)[9] * params$summer.mean.temp[i]
  } else if (params$reproduction[i] == "veg" && params$trt[i] == "drought") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] +   fixef(gm.summer.av.temp.cor.trt.int6)[4] + 
      fixef(gm.summer.av.temp.cor.trt.int6)[8] * params$summer.mean.temp[i] + 
      fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i]
  } else if (params$reproduction[i] == "flowered" && params$trt[i] == "drought") {
    params$growth.int[i] <- fixef(gm.summer.av.temp.cor.trt.int6)[1] + #intercept
      fixef(gm.summer.av.temp.cor.trt.int6)[3] + #pflower = 1 intercept
      fixef(gm.summer.av.temp.cor.trt.int6)[4] + #trt = drought int
      fixef(gm.summer.av.temp.cor.trt.int6)[6] * params$summer.mean.temp[i] + fixef(gm.summer.av.temp.cor.trt.int6)[8] * params$summer.mean.temp[i]
  }
}

#slope for growth
params$growth.slope[params$reproduction == "veg"] <- fixef(gm.summer.av.temp.cor.trt.int6)[2]
params$growth.slope[params$reproduction == "flowered"]<- fixef(gm.summer.av.temp.cor.trt.int6)[2] + fixef(gm.summer.av.temp.cor.trt.int6)[7]

params$growth.sd <- growth_var[growth_var$grp=="Residual","sdcor"] # growth sd of residuals

###########################################################################################
#survival = sm.gs.av.temp
for (i in 1:nrow(params)) {
  params$surv.int[i] <- fixef(sm.gs.av.temp)[1] + fixef(sm.gs.av.temp)[3]*params$grow.season.mean.temp[i]
}

#slope
params$surv.slope <- fixef(sm.gs.av.temp)[2] # survival size t
###########################################################################################
#pflower
for (i in 1:nrow(params)) {
  if (params$reproduction[i] == "veg") {
    params$pflow.int[i] <- fixef(fm.gs.av.temp.cor.int1)[1] + fixef(fm.gs.av.temp.cor.int1)[4] * params$grow.season.mean.temp[i]
  } else if (params$reproduction[i] == "flowered") {
    params$pflow.int[i] <- fixef(fm.gs.av.temp.cor.int1)[1] + fixef(fm.gs.av.temp.cor.int1)[4] * params$grow.season.mean.temp[i] + fixef(fm.gs.av.temp.cor.int1)[3]
  }
}

#slopes:
params$pflow.slope[params$reproduction == "veg"] <- fixef(fm.gs.av.temp.cor.int1)[2]
params$pflow.slope[params$reproduction == "flowered"]<- fixef(fm.gs.av.temp.cor.int1)[2] + fixef(fm.gs.av.temp.cor.int1)[5]
##############################################################################################
# no.flowers
for (i in 1:nrow(params)) {
    params$no.flow.int[i] <- fixef(noflowers.winter.av.temp)[1] + fixef(noflowers.winter.av.temp)[3]*params$winter.mean.temp[i]
}

params$no.flow.slope <- fixef(noflowers.winter.av.temp)[2] # flower number production size t
#####

#currently, seeds per flower is not size dependent, but is treatment dependent
#flowers in drought plots make 6 seeds, control make 11, irrigated make 13
params$seeds[params$trt == "irrigated"] <- 13
params$seeds[params$trt == "drought"] <- 6
params$seeds[params$trt == "control"] <- 11

#params$no.seeds <- no.seeds
params$prob.seed.germ <- prob.seed.germ
params$recruit.size.mean <- new_mean # mean new >1 leaf plant size
params$recruit.size.sd<- new_sd # sd of new >1 leaf plant size

params$growth.sd <- growth_var[growth_var$grp=="Residual","sdcor"] # growth sd of residuals

```

# Build the model!

### Step 1. Build vital rate functions (components of the kernel)

```{r without bootstrap functions}
###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
###         Load functions
###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#SURVIVAL AT SIZE X
s.x=function(x,params) {
	u=exp(params$surv.int+params$surv.slope*x)
	return(u/(1+u))
}

#how to test this: 
### run function for a plant of size 1 and for the first row of parameters
#s.x(x = 1, params = params[1,])
### run function for a plant of size 1 but for all rows of parameters (so get a list )
#s.x(x = 1, params = params)
#ok this works and seems to work for all rows of params. great.

#GROWTH FROM SIZE X TO Y; 
  ## returns a *probability density distribution* for each x value
g.yx<-function(y,x,params){
    # eviction here...
  xb=pmin(pmax(x,minRealsize),maxRealsize) #Transforms all values below/above limits in min/max size (floor & ceiling)
  growth_to_newsize <-params$growth.int + params$growth.slope*xb
  growth_sd <- params$growth.sd
  return(dnorm(y,mean=growth_to_newsize,sd=growth_sd))
  #dnorm(y,mean=params$growth.int + params$growth.slope*x,sd=params$growth.sd)

}
#to test this:
###well actually, maybe I don't know what the end product is supposed to look like - and is y the size it grows to ve
#g.yx(y = 1, x = 1, params = params[1,])

#Tom Miller's combined s and g kernel
P <- function(y, x, params){
  s.x(x, params)*g.yx(y, x, params)
}



#PROBABILITY OF FLOWERING OF SIZE X individuals
pf.x <-function(x,params){
	u<-exp(params$pflow.int+params$pflow.slope*x)
	return(u/(1+u))
}
#testing this for a plant of size 5
#pf.x(x = 8,params = params)

# #PRODUCTION OF seedlings by X-SIZED plants that flowered the previous year
###Here i've put in the misc bits, but not sure if this is correct - seems ok for now

# f.yx.flowered=function(x,params) { 		
# 	return(pf.x.flowered(x,params)*
#     exp(params$no.flow.int+params$no.flow.slope*x)*
#     params$p.flower.makes.seed*
#     params$no.seeds* #this will eventually be a function??
#     params$prob.seed.germ)
#  #is this right? I want a number of seedlings that are made.
# }

f.yx=function(x,params) { 		
	#return(pf.x(x,params)*exp(params$no.flow.int+params$no.flow.slope*x)* exp(params$no.seeds.int+params$no.seeds.slope*x) *
  return(pf.x(x,params)*exp(params$no.flow.int+params$no.flow.slope*x)* params$seeds * params$prob.seed.germ)
}
##so this should be outputting the number of seedlings made? Yes
#f.yx(x = 5,params = params)

##do big plants make a million flowers?
#exp(params$no.flow.int+params$no.flow.slope*8) 
## no they make a reasonable amount


#SIZE DISTRIBUTION OF RECRUITS - so the ones going from the 1 leaf stage into the continuous stage. I'm not sure that this is doing what I want it to - 
recruit.size<-function(y,params){
    ## returns a *probability density distribution*
  dnorm(y,mean=params$recruit.size.mean,sd=params$recruit.size.sd)
}
```


```{r with bootstrap functions}
###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
###         Load functions
###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#SURVIVAL AT SIZE X
s.x=function(x,boot.params) {
	u=exp(boot.params$surv.int+boot.params$surv.slope*x)
	return(u/(1+u))
}

#how to test this: 
### run function for a plant of size 1 and for the first row of parameters
#s.x(x = 1, boot.params = boot.params[1,])
### run function for a plant of size 1 but for all rows of parameters (so get a list )
#s.x(x = 1, boot.params = boot.params)
#ok this works and seems to work for all rows of boot.params. great.

#GROWTH FROM SIZE X TO Y; 
  ## returns a *probability density distribution* for each x value
g.yx<-function(y,x,boot.params){
    # eviction here...
  xb=pmin(pmax(x,minRealsize),maxRealsize) #Transforms all values below/above limits in min/max size (floor & ceiling)
  growth_to_newsize <-boot.params$growth.int + boot.params$growth.slope*xb
  growth_sd <- boot.params$growth.sd
  return(dnorm(y,mean=growth_to_newsize,sd=growth_sd))
  #dnorm(y,mean=boot.params$growth.int + boot.params$growth.slope*x,sd=boot.params$growth.sd)

}
#to test this:
###well actually, maybe I don't know what the end product is supposed to look like - and is y the size it grows to ve
#g.yx(y = 1, x = 1, boot.params = boot.params[1,])

#Tom Miller's combined s and g kernel
P <- function(y, x, boot.params){
  s.x(x, boot.params)*g.yx(y, x, boot.params)
}



#PROBABILITY OF FLOWERING OF SIZE X individuals
pf.x <-function(x,boot.params){
	u<-exp(boot.params$pflow.int+boot.params$pflow.slope*x)
	return(u/(1+u))
}
#testing this for a plant of size 5
#pf.x(x = 8,boot.params = boot.params)

# #PRODUCTION OF seedlings by X-SIZED plants that flowered the previous year
###Here i've put in the misc bits, but not sure if this is correct - seems ok for now

# f.yx.flowered=function(x,boot.params) { 		
# 	return(pf.x.flowered(x,boot.params)*
#     exp(boot.params$no.flow.int+boot.params$no.flow.slope*x)*
#     boot.params$p.flower.makes.seed*
#     boot.params$no.seeds* #this will eventually be a function??
#     boot.params$prob.seed.germ)
#  #is this right? I want a number of seedlings that are made.
# }

f.yx=function(x,boot.params) { 		
	#return(pf.x(x,boot.params)*exp(boot.params$no.flow.int+boot.params$no.flow.slope*x)* exp(boot.params$no.seeds.int+boot.params$no.seeds.slope*x) *
  return(pf.x(x,boot.params)*exp(boot.params$no.flow.int+boot.params$no.flow.slope*x)* boot.params$seeds * boot.params$prob.seed.germ)
}
##so this should be outputting the number of seedlings made? Yes
#f.yx(x = 5,boot.params = boot.params)

##do big plants make a million flowers?
#exp(boot.params$no.flow.int+boot.params$no.flow.slope*8) 
## no they make a reasonable amount


#SIZE DISTRIBUTION OF RECRUITS - so the ones going from the 1 leaf stage into the continuous stage. I'm not sure that this is doing what I want it to - 
recruit.size<-function(y,boot.params){
    ## returns a *probability density distribution*
  dnorm(y,mean=boot.params$recruit.size.mean,sd=boot.params$recruit.size.sd)
}
```

```{r get lambdas (no bootstrap no ltre)}
params_list <-  filter(params) %>% split(., seq(nrow(.))) #this splits up params into X rows, which I can feed into the function below


#params_in <- params_list[1] #to test it!
# BIGMATRIX ---------------------------------------------------------------
#building off of code from Tom Miller:
mat.size = 100 #dimensions of continuous matrix
bigmatrix<-function(params_list, mat.size)
  {
  n<-mat.size
  L<-min.size
  U<-max.size
  #these are the upper and lower integration limits
  h<-(U-L)/n                   #Bin size
  b<-L+c(0:n)*h;               #Lower boundaries of bins 
  y<-0.5*(b[1:n]+b[2:(n+1)]);  #Bins' midpoints
  #these are the boundary points (b) and mesh points (y)

  # Fertility matrix
  Fmat<-matrix(0,(n+2),(n+2))
  
  # top row: # seedlings produced by each size class:
  Fmat[1,3:(n+2)]<-f.yx(y,params_list) #This is a y because it is the fecundity kernel for plants that have already grown/survived, I think? It's what Tom has
  
  # Growth/survival transition matrix
  Tmat<-matrix(0,(n+2),(n+2))
  
  # probability seedling becomes a 1 leaf plant
  Tmat[2,1]<- prob.seedling.to.1leaf
  
   # probability 1 leaf plant stays as a 1 leaf plant
  Tmat[2,2]<- prob.1leaf.to.1leaf
  
  # Graduation from 1 leaf to cts size = prob 1 leaf becomes a 2 leaf * size dist of new 2 leafers
  Tmat[3:(n+2),2]<- prob.1leaf.to.2leaf *recruit.size(y,params_list) * h
  
  # Growth/survival transitions among cts sizes
  Tmat[3:(n+2),3:(n+2)]<- t(outer(y,y,P,params=params_list)) * h 
  
  # Put it all together
  IPMmat<-Fmat+Tmat     #Full Kernel is simply a summation of fertility and transition matrix
  out_matrix <- list(IPMmat=IPMmat,Fmat=Fmat,Tmat=Tmat,meshpts=y)
  
  out_lamb <- data.frame(lambda = lambda(IPMmat), summer.temp = params_list$summer.mean.temp,  gs.temp = params_list$grow.season.mean.temp, winter.temp = params_list$winter.mean.temp, reproduction = params_list$reproduction, trt = params_list$trt)
 # return(out_matrix) #can check this to have a list of all of the matrices listed above
  return(out_lamb) #for now, I just want lambdas
 # return(list(out_matrix = out_matrix, out_lamb = out_lamb))

}

#what I want returned is lambdas
lamb_lists <- lapply(X = params_list, FUN = bigmatrix, mat.size = mat.size) #for each row of params_list, run the big matrix function!
#great~! now make it a df
primula_lambda <- do.call(rbind, lamb_lists)
#write.csv(primula_lambda, "../tables/primula.climate.lambdas.2023.01.09.csv", row.names = F)


```

```{r get bootstrapped lambdas)}
params_list <-  filter(boot.params) %>% split(., seq(nrow(.))) #this splits up params into X rows, which I can feed into the function below


#params_in <- params_list[1] #to test it!
# BIGMATRIX ---------------------------------------------------------------
#building off of code from Tom Miller:
mat.size = 100 #dimensions of continuous matrix
bigmatrix<-function(params_list, mat.size)
  {
  n<-mat.size
  L<-min.size
  U<-max.size
  #these are the upper and lower integration limits
  h<-(U-L)/n                   #Bin size
  b<-L+c(0:n)*h;               #Lower boundaries of bins 
  y<-0.5*(b[1:n]+b[2:(n+1)]);  #Bins' midpoints
  #these are the boundary points (b) and mesh points (y)

  # Fertility matrix
  Fmat<-matrix(0,(n+2),(n+2))
  
  # top row: # seedlings produced by each size class:
  Fmat[1,3:(n+2)]<-f.yx(y,params_list) #This is a y because it is the fecundity kernel for plants that have already grown/survived, I think? It's what Tom has
  
  # Growth/survival transition matrix
  Tmat<-matrix(0,(n+2),(n+2))
  
  # probability seedling becomes a 1 leaf plant
  Tmat[2,1]<- prob.seedling.to.1leaf
  
   # probability 1 leaf plant stays as a 1 leaf plant
  Tmat[2,2]<- prob.1leaf.to.1leaf
  
  # Graduation from 1 leaf to cts size = prob 1 leaf becomes a 2 leaf * size dist of new 2 leafers
  Tmat[3:(n+2),2]<- prob.1leaf.to.2leaf *recruit.size(y,params_list) * h
  
  # Growth/survival transitions among cts sizes
  Tmat[3:(n+2),3:(n+2)]<- t(outer(y,y,P,boot.params=params_list)) * h 
  
  # Put it all together
  IPMmat<-Fmat+Tmat     #Full Kernel is simply a summation of fertility and transition matrix
  out_matrix <- list(IPMmat=IPMmat,Fmat=Fmat,Tmat=Tmat,meshpts=y)
  
  out_lamb <- data.frame(lambda = lambda(IPMmat), summer.temp = params_list$summer.mean.temp,  gs.temp = params_list$grow.season.mean.temp, winter.temp = params_list$winter.mean.temp, reproduction = params_list$reproduction, trt = params_list$trt, boot.group = params_list$boot.group)
 # return(out_matrix) #can check this to have a list of all of the matrices listed above
  return(out_lamb) #for now, I just want lambdas
 # return(list(out_matrix = out_matrix, out_lamb = out_lamb))

}

#what I want returned is lambdas
lamb_lists <- lapply(X = params_list, FUN = bigmatrix, mat.size = mat.size) #for each row of params_list, run the big matrix function!
#great~! now make it a df
boot_lambda <- do.call(rbind, lamb_lists)
#write.csv(boot_lambda, "../tables/primula.bootstrap.climate.lambdas.2023.02.02.csv", row.names = F)


```

```{r bootstrap figures}
quant <- boot_lambda %>% 
  group_by(summer.temp, gs.temp, winter.temp, reproduction, trt) %>% 
  summarize(mean.lambda = mean(lambda),
            upper.quant = quantile(lambda, probs = 0.975),
            lower.quant = quantile(lambda, probs = 0.025))

#library(gridExtra)
library("patchwork")


q.gs <- quant %>% 
  filter(summer.temp == 0 & winter.temp == 0) %>% 
  ggplot(aes(x = gs.temp, y = mean.lambda, color = trt, linetype = reproduction))+
  geom_line(linewidth = 1.25)+
  geom_ribbon(aes(x = gs.temp, ymin = lower.quant, ymax = upper.quant, fill = trt), alpha = 0.1)+
  facet_wrap(~trt)+
  scale_color_manual(values = c(Z[3], Z[5], Z[1]), name = "")+
  scale_fill_manual(values = c(Z[3], Z[5], Z[1]), name = "")+
  labs(y = expression(paste("\u03BB")), x = "Spring Temperature")+
  theme(strip.background = element_blank(), strip.text.x = element_blank()) #remove facet wrap labels


q.sum <- quant %>% 
  filter(gs.temp == 0 & winter.temp == 0) %>% 
  ggplot(aes(x = summer.temp, y = mean.lambda, color = trt, linetype = reproduction))+
  geom_line(linewidth = 1.25)+
  geom_ribbon(aes(x = summer.temp, ymin = lower.quant, ymax = upper.quant, fill = trt), alpha = 0.1)+
  facet_wrap(~trt)+
  scale_color_manual(values = c(Z[3], Z[5], Z[1]), name = "")+
  scale_fill_manual(values = c(Z[3], Z[5], Z[1]), name = "")+
  labs(y = expression(paste("\u03BB")), x = "Summer Temperature")+
  theme(strip.background = element_blank(), strip.text.x = element_blank()) #remove facet wrap labels


q.win <- quant %>% 
  filter(summer.temp == 0 & gs.temp == 0) %>% 
  ggplot(aes(x = winter.temp, y = mean.lambda, color = trt, linetype = reproduction))+
  geom_line(linewidth = 1.25)+
  geom_ribbon(aes(x = winter.temp, ymin = lower.quant, ymax = upper.quant, fill = trt), alpha = 0.1)+
  facet_wrap(~trt)+
  scale_color_manual(values = c(Z[3], Z[5], Z[1]), name = "")+
  scale_fill_manual(values = c(Z[3], Z[5], Z[1]), name = "")+
  labs(y = expression(paste("\u03BB")), x = "Winter Temperature")+
  theme(strip.background = element_blank(), strip.text.x = element_blank()) #remove facet wrap labels

boot.ipm <- q.gs + q.sum +  q.win + plot_layout(guides = "collect", ncol = 1)
#ggsave(plot = boot.ipm, file = "C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/Figures/ipm bootstrap.png", width = 10, height = 10, dpi = 300)


```




```{r LTRE functions}
#goal: make a params vector that only includes mean temps so we can look at difference between lambda for RE;
params_ltre <- params %>% 
  filter(summer.mean.temp == 0,
         winter.mean.temp == 0,
         grow.season.mean.temp == 0, 
         trt == control)
ltre_list <-  filter(params_ltre) %>% split(., seq(nrow(.))) #this splits up params into X rows, which I can feed into the function below


# BIGMATRIX ---------------------------------------------------------------
#building off of code from Tom Miller:
mat.size = 100 #dimensions of continuous matrix
bigmatrix<-function(ltre_list, mat.size)
  {
  n<-mat.size
  L<-min.size
  U<-max.size
  #these are the upper and lower integration limits
  h<-(U-L)/n                   #Bin size
  b<-L+c(0:n)*h;               #Lower boundaries of bins 
  y<-0.5*(b[1:n]+b[2:(n+1)]);  #Bins' midpoints
  #these are the boundary points (b) and mesh points (y)

  # Fertility matrix
  Fmat<-matrix(0,(n+2),(n+2))
  
  # top row: # seedlings produced by each size class:
  Fmat[1,3:(n+2)]<-f.yx(y,ltre_list) #This is a y because it is the fecundity kernel for plants that have already grown/survived, I think? It's what Tom has
  
  # Growth/survival transition matrix
  Tmat<-matrix(0,(n+2),(n+2))
  
  # probability seedling becomes a 1 leaf plant
  Tmat[2,1]<- prob.seedling.to.1leaf
  
   # probability 1 leaf plant stays as a 1 leaf plant
  Tmat[2,2]<- prob.1leaf.to.1leaf
  
  # Graduation from 1 leaf to cts size = prob 1 leaf becomes a 2 leaf * size dist of new 2 leafers
  Tmat[3:(n+2),2]<- prob.1leaf.to.2leaf *recruit.size(y,ltre_list) * h
  
  # Growth/survival transitions among cts sizes
  Tmat[3:(n+2),3:(n+2)]<- t(outer(y,y,P,params=ltre_list)) * h 
  
  # Put it all together
  IPMmat<-Fmat+Tmat     #Full Kernel is simply a summation of fertility and transition matrix
  out_matrix <- list(IPMmat=IPMmat,Fmat=Fmat,Tmat=Tmat,meshpts=y)
  
  out_lamb <- data.frame(lambda = lambda(IPMmat), summer.temp = ltre_list$summer.mean.temp,  gs.temp = ltre_list$grow.season.mean.temp, winter.temp = ltre_list$winter.mean.temp, reproduction = ltre_list$reproduction, trt = ltre_list$trt)
 return(out_matrix) #can check this to have a list of all of the matrices listed above
  return(out_lamb) #for now, I just want lambdas
  return(list(out_matrix = out_matrix, out_lamb = out_lamb))

}

#what I want returned is lambdas
lamb_lists <- lapply(X = ltre_list, FUN = bigmatrix, mat.size = mat.size) #for each row of params_list, run the big matrix function!

#great~! now make it a df
primula_lambda <- do.call(rbind, lamb_lists)
#write.csv(primula_lambda, "../tables/primula.climate.lambdas.2023.01.09.csv", row.names = F)


 ltre <- function(intercept){
    #store LTREs
    ltre.rep.control <- c()
    ltre.veg.control <- c()
    
    ltre.rep.drought <- c()
    ltre.veg.drought <- c()

    ltre.rep.irrigated <- c()
    ltre.veg.irrigated <- c()
    
  perturbation<-0.01
  
  params_ltre_pert <- params_ltre
  params_ltre_pert[intercept]<-params_ltre[intercept] + perturbation 
  pert.matrix <- bigmatrix(n = 500, params = params_ltre_pert)$matrix
  perturblam=lambda(pert.matrix)
  
  #nitrogen intercept
  ltre.N<-append(ltre.N,(params.N[intercept] - params.C[intercept])*((perturblam-lambda.C[i])/perturbation))
  
  #fenced intercept
  ltre.H<-append(ltre.H,(params.H[intercept] - params.C[intercept])*((perturblam-lambda.C[i])/perturbation))
  
  #both intercept
  ltre.NH<-append(ltre.NH,(params.NH[intercept] - params.C[intercept])*((perturblam-lambda.C[i])/perturbation))

  output = list("ltreN" = ltre.N, "ltreH" =ltre.H, "ltreNH" =ltre.NH) #need the ith matrix to calculate these three terms - this avoids pasting 15 times (5 rates x 3 treatments)
  return(output)}
  
  #tells it what to put in for intercept in the function
  growthint=ltre("growthint") #this is the equivalent of saying intercept = growthint and store the output of this function as growthint
  survint=ltre("survint")
  flowint=ltre("flowint")
  fertint=ltre("fertint")
  repoutint=ltre("repoutint")
  
  #means of ith run
  listoutput[[i]]=data.frame('nitrogen'=c(growthint[[1]], survint[[1]], flowint[[1]], fertint[[1]], repoutint[[1]]), 
                             'fenced'=c(growthint[[2]], survint[[2]], flowint[[2]], fertint[[2]], repoutint[[2]]),#based on order in output statement 
                             'both'=c(growthint[[3]], survint[[3]], flowint[[3]], fertint[[3]], repoutint[[3]]))
 


ltre.df=do.call(rbind,listoutput)

ltre.df$vrate=row.names(ltre.df)

#####growth ltre#####
growthint=ltre.df[grep("growthint",ltre.df$vrate),] 
hist(growthint$nitrogen)
mean(growthint$nitrogen)
quantile(growthint$nitrogen, c(0.025, 0.975))
#-5.329672e-05, CI = -0.0012116911  0.0006165014
growthint=ltre.df[grep("growthint",ltre.df$vrate),] 
hist(growthint$fenced)
mean(growthint$fenced)
quantile(growthint$fenced, c(0.025, 0.975))
#-0.0001409152, CI = -0.0011739342  0.0006483204 
growthint=ltre.df[grep("growthint",ltre.df$vrate),] 
hist(growthint$both)
mean(growthint$both)
quantile(growthint$both, c(0.025, 0.975))
# -0.0002628167, CI = -0.002391176  0.001137288 

#####survival ltre#####
survint=ltre.df[grep("survint",ltre.df$vrate),] 
hist(survint$nitrogen)
mean(survint$nitrogen)
quantile(survint$nitrogen, c(0.025, 0.975))
# -0.2339654, CI =-0.3162971 -0.1622143 
survint=ltre.df[grep("survint",ltre.df$vrate),] 
hist(survint$fenced)
mean(survint$fenced)
quantile(survint$fenced, c(0.025, 0.975))
# 0.003387016, CI = -0.06843332  0.07386618
survint=ltre.df[grep("survint",ltre.df$vrate),] 
mean(survint$both)
quantile(survint$both, c(0.025, 0.975))
# -0.2455, CI =-0.3681219 -0.1268373  

#####flow ltre#####
flowint=ltre.df[grep("flowint",ltre.df$vrate),] 
hist(flowint$nitrogen)
mean(flowint$nitrogen)
quantile(flowint$nitrogen, c(0.025, 0.975))
#-2.164524e-05, CI = -0.0006638401  0.0005875821
flowint=ltre.df[grep("flowint",ltre.df$vrate),] 
hist(flowint$fenced)
mean(flowint$fenced)
quantile(flowint$fenced, c(0.025, 0.975))
# 0.0001541924, CI = -0.0004514011  0.0011038207 
flowint=ltre.df[grep("flowint",ltre.df$vrate),] 
mean(flowint$both)
quantile(flowint$both, c(0.025, 0.975))
# 0.0004633819, CI =-0.0003460376  0.0019321087 

#####fert ltre#####
fertint=ltre.df[grep("fertint",ltre.df$vrate),] 
hist(fertint$nitrogen)
mean(fertint$nitrogen)
quantile(fertint$nitrogen, c(0.025, 0.975))
# -0.0002537499, CI = -0.001481542  0.000649442
fertint=ltre.df[grep("fertint",ltre.df$vrate),] 
hist(fertint$fenced)
mean(fertint$fenced)
quantile(fertint$fenced, c(0.025, 0.975))
#  0.000848387, CI = -2.131169e-05  2.888305e-03
fertint=ltre.df[grep("fertint",ltre.df$vrate),] 
mean(fertint$both)
quantile(fertint$both, c(0.025, 0.975))
#   0.0009542077, CI =-0.0004013281  0.0038135281 

#####repout ltre#####
repoutint=ltre.df[grep("repoutint",ltre.df$vrate),] 
hist(repoutint$nitrogen)
mean(repoutint$nitrogen)
quantile(repoutint$nitrogen, c(0.025, 0.975))
# -0.001767512, CI =-0.0052317037 -0.0004189991
repoutint=ltre.df[grep("repoutint",ltre.df$vrate),] 
hist(repoutint$fenced)
mean(repoutint$fenced)
quantile(repoutint$fenced, c(0.025, 0.975))
#-0.0001335385, CI = -0.0012575774  0.0008001218 
repoutint=ltre.df[grep("repoutint",ltre.df$vrate),] 
mean(repoutint$both)
quantile(repoutint$both, c(0.025, 0.975))
# -0.0005224892, CI =-0.002976771  0.001192056 

#####lambda estimates#####
lambda.C[i]
hist(lambda.C) 
quantile(lambda.C, c(0.025, 0.975))
#lambda = 0.642775, CI = 0.5271378 0.6745559  

lambda.N[i]
hist(lambda.N)
quantile(lambda.N, c(0.025, 0.975))
#lambda =   0.4207083, CI = 0.2655970 0.4674194 

lambda.H[i]
hist(lambda.H)
quantile(lambda.H, c(0.025, 0.975))
#lambda = 0.6530463, CI = 0.5044639 0.7131563  

lambda.NH[i]
hist(lambda.NH)
quantile(lambda.NH, c(0.025, 0.975))
#lambda =    0.4850833, CI = 0.2367758 0.724911 

```





#just grab one of the matrices to see what's going on with the kernels
```{r testing one matrix}
save <- bigmatrix(params = params[10,], mat.size = mat.size)

#this is code that works for just one set of params
# primula_lambda <- bigmatrix(params = params_in,
#                             mat.size = mat.size)

popbio::image2(save$IPMmat)
image(save$Fmat,main='F kernel - control flowered')	
image(save$Tmat,main='S+G kernel - control flowered')	
abline(0,1,lwd=3)	
lambda(save$IPMmat)

IPMmat <- save$IPMmat

# Assuming save$IPMmat is a big matrix (e.g., 102 by 102)
IPMmat <- save$IPMmat

# Exclude the first two rows and columns
subset_matrix <- IPMmat[3:nrow(IPMmat), 3:ncol(IPMmat)]

# Create the image plot
image(
  1:(ncol(subset_matrix)),      # x-axis values
  1:(nrow(subset_matrix)),      # y-axis values
  subset_matrix,                # Matrix for z-axis values
  main = "IPM Matrix",          # Main title
  xlab = "Column Index",        # X-axis label
  ylab = "Row Index"            # Y-axis label
)

mtext("e)", side = 3, cex = 0.9, adj = 0, line = 0.1)


#for the full kernel, is the Fmat gettign swamped out by the Tmat?
# sometimes it's hard to see both the fecundity part of the kernel swamps the growth/survival part, so here's a plotting trick to level out the kernel
image2(save$IPMmat^.3,main='full kernel^0.3') #ok, that works!	but these kernels look weird (ie the t+1 side is flipped and has wrong scale...not sure how to fix that)

image.plot(save$IPMmat, xlab="Size (t)",ylab="Size (t+1)",
col=topo.colors(100), main="IPM matrix")

```
```{r how many seedlings produced?}
#use this code to check and see how many seedlings are produced by each size class
matrix <- as.data.frame(save$IPMmat)
no.seedlings <- matrix[1,]
no.seedlings <- no.seedlings %>% pivot_longer(
    cols = starts_with("V"),
    values_to = "no.seedlings",
    names_to = "size",
    names_pattern = "V(.*)")
barplot(no.seedlings$no.seedlings, xlab = "Plant size (small to large)", ylab = "Number of seedlings produced")

#and use this code to see p(1 leaf becomes a 2 leaf)* size distribution of new individuals into kernel
new.cont <- matrix[3:102,2]
barplot(new.cont, ylab = "Prob. 1 leaf becomes >2 leaf * size distribution of new >2 leafs", xlab = "Plant size (small to large)")

```


```{r}
# #now to make a graph:
# 
ipm <- primula_lambda %>%
  ggplot(aes(x = precip, y = lambda, linetype = reproduction))+
  geom_line(data = subset(primula_lambda, temp == 8.14), aes(x = precip, y = lambda), color = "lightblue2",  size = 1.25)+
  geom_line(data = subset(primula_lambda, temp == 9.64), aes(x = precip, y = lambda), color = "darkgrey", size = 1.25)+
  geom_line(data = subset(primula_lambda, temp == 11.14), aes(x = precip, y = lambda), color = "firebrick", size = 1.25)+
  labs(x = "Growing Season Total Precipitation (mm)", y = "Lambda")+
  scale_linetype_manual(values=c("longdash", "solid"))+
  theme(legend.position="none")

ggplot(primula_lambda, aes(x = summer.temp, y = gs.temp, fill = lambda)) +
   geom_tile(color = "black") +
   scale_fill_gradient(low = "white", high = "red")
# 
# ggsave(plot = ipm, file = "C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/Figures/ipm climate.png", width = 5, height = 5, dpi = 300)

```

```{r fig. lambda per year}
#looking at lambdas per year:
primula_lambda %>% 
  ggplot(aes(x = year, y = lambda, color = trt, shape = reproduction))+
  geom_point(size = 2)+
    scale_color_manual(values = c("#E7B800", "#FC4E07", "#00AFBB"), name = "")+
  scale_shape_manual(values = c(1, 16))
#change reproduction to cost vs no cost
  

```

 
 


```{r climate lambda figures no boot}
#summer.precip changing while summer precip, sumer temp, etc does not
# sp <- primula_lambda %>% 
#   filter(near(summer.temp, 0, tol = .1)) %>% 
#   filter(near(gs.temp, 0, tol = .1)) %>% 
#   filter(near(winter.temp, 0, tol = .2)) %>% 
#   ggplot(aes(x = summer.precip, y = lambda, linetype = reproduction, color = trt))+
#   geom_line(linewidth = 1.5)+
#   scale_color_manual(values = c("#E7B800", "#FC4E07", "#00AFBB"), name = "")+
#   scale_linetype_manual(values = c("solid", "dashed"), labels = c("cost", "no cost"), name = "")+
#   labs(y = expression(paste("\u03BB")), x = "Summer Precipitation")
st <- primula_lambda %>% 
  #filter(near(summer.temp, 0, tol = .1)) %>% 
  filter(near(gs.temp, 0, tol = .1)) %>% 
  filter(near(winter.temp, 0, tol = .2)) %>% 
  ggplot(aes(x = summer.temp, y = lambda, linetype = reproduction, color = trt))+
  geom_line(linewidth = 1.5)+
  scale_color_manual(values = c(Z[3], Z[5], Z[1]), name = "")+
 scale_linetype_manual(values = c( "dashed","solid"), name = "")+
  labs(y = expression(paste("\u03BB")), x = "Summer Temperature")+
  scale_y_continuous(limits=c(.875,1))+ 
  theme(legend.position = "none")+
  geom_hline(yintercept = 1, color="grey", linetype="dashed", linewidth = 1.25)
gst <- primula_lambda %>% 
  filter(near(summer.temp, 0, tol = .1)) %>% 
  filter(near(winter.temp, 0, tol = .2)) %>% 
  ggplot(aes(x = gs.temp, y = lambda, linetype = reproduction, color = trt))+
  geom_line(linewidth = 1.5)+
  scale_color_manual(values = c(Z[3], Z[5], Z[1]), name = "")+
  scale_linetype_manual(values = c("dashed", "solid"), name = "")+
  labs(y = expression(paste("\u03BB")), x = "Spring Temperature")+
  scale_y_continuous(limits=c(.875,1))+
  geom_hline(yintercept = 1, color="grey", linetype="dashed", linewidth = 1.25)+ 
  theme(legend.position = "none")

wt <- primula_lambda %>% 
  filter(near(summer.temp, 0, tol = .1)) %>% 
  filter(near(gs.temp, 0, tol = .2)) %>% 
  ggplot(aes(x = winter.temp, y = lambda, linetype = reproduction, color = trt))+
  geom_line(linewidth = 1.5)+
  scale_color_manual(values = c(Z[3], Z[5], Z[1]), name = "")+
  scale_linetype_manual(values = c("dashed", "solid"), name = "")+
  labs(y = expression(paste("\u03BB")), x = "Winter Temperature")+
  scale_y_continuous(limits=c(.875,1))+ 
  theme(legend.position = "none")+
  geom_hline(yintercept = 1, color="grey", linetype="dashed", linewidth = 1.25)





ggsave(plot = st, file = "C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/Figures/IPM/1st.png", width = 5, height = 4, dpi = 300)
ggsave(plot = gst, file = "C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/Figures/IPM/1gst.png", width =5, height = 4, dpi = 300)
ggsave(plot = wt, file = "C:/Users/Jenna/OneDrive - The University Of British Columbia/Data Projects/Primula/Figures/IPM/1wt.png", width = 5, height = 4, dpi = 300)

```


Ok! These run! Obviously some things are missing and will need to change, but at least I get some lambdas! 

What does it mean to compare lambda across these? Can we just think about fitness here??
Wait, why is lambda for ones that flowered in t-1 HIGHER than ones that didn't flower?????
That seems really weird...will think about it more
At least drought lambda is lower, although control and irrigated arent that different
