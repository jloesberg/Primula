---
title: "GOERT analyses"
author: "JL"
date: "`r Sys.Date()`"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(AICcmodavg)
library(lme4)
library(popbio)
theme_set(theme_classic()) #for ggplot
```

```{r}
### read in all years of Primula data and weather data from the Cowichan
# Add in climate data:
source("../scripts/Cowichan_climatevalues.R")

# Add in demography data:
# Add in demography data:
source("../scripts/dode_allyears_cleaned.R")

## Join climate data to demography data by year
primula <- left_join(Dodecatheon, climate, by = "year") %>%
  #i solved these:
  # filter(tag!= "1881") %>% 
  # filter(tag!= "1471") %>% 
  # filter(tag!= "1183") %>% 
  # filter(tag!= "8317") %>% 
  # filter(tag!= "8311") %>% 
  # filter(tag!= "8315") %>% 
  mutate(pflower = as.factor(pflower),
         pflowerT1 = as.factor(pflowerT1),
         psurvivalT1 = as.factor(psurvivalT1))
remove( Dodecatheon)

#gives a warning but I think it's fine!

new.plants <- primula %>%   
  mutate(leaves = if_else(year == 2022, no.smleaf + no.bigleaf, leaves)) %>% 
  filter(year == YrTag) %>% ##need to filter cases where year tagged == year (so newly tagged that year)
  filter(pflower == 0) %>% ## actual new plants definitely can't flower in the first year
  filter(leaves < 3) %>% 
  filter(!is.na(log.ros.area))
```

##IPM for Primula data
```{r}
#load best fit models from primula_climate_VR.r"
# 
# gm17 <- lmer(log.ros.areaT1 ~ log.ros.area + trt * grow.season.mean.max.temp+ (1|plot) + (1|year), data = primula) ###
#   growth_var <- as.data.frame(VarCorr(gm17)) #assumes same variance across all, not sure if thats ok
# fm.f16 <- glmer(pflowerT1 ~ log.ros.area * pflower + grow.season.mean.max.temp+ (1|plot) + (1|year), data = primula, family = "binomial")
# sm10lag <- glmer(psurvivalT1 ~ log.ros.area*grow.season.min.temp.1yearlag+ (1|plot) + (1|year), data = primula, family = "binomial") ###
# noflow9 <- glm(flow.sum ~ log.ros.area + grow.season.mean.min.temp, data = subset(primula, flow.sum > 0), family = "poisson")

#fm.gs.precip.cor.trt.int10 <- glmer(pflowerT1 ~ log.ros.area*grow.season.tot.precip.scale*pflower + trt + (1|plot) + (1|year), data = primula, family = "binomial")
#pflower1 <- glmer(pflowerT1 ~ log.ros.area + (1|plot) + (1|year), data = primula, family = "binomial")
pflower2 <- glmer(pflowerT1 ~ log.ros.area + trt + (1|plot) + (1|year), data = primula, family = "binomial")
#pflower3 <- glmer(pflowerT1 ~ log.ros.area*trt +(1|plot) + (1|year), data = primula, family = "binomial")


surv1 <- glmer(psurvivalT1 ~ log.ros.area + (1|plot) + (1|year), data = primula, family = "binomial")
#surv2 <- glmer(psurvivalT1 ~ log.ros.area + trt+ (1|plot) + (1|year), data = primula, family = "binomial")
#surv3 <- glmer(psurvivalT1 ~ log.ros.area*trt+ (1|plot) + (1|year), data = primula, family = "binomial")

#growth1 <- lmer(log.ros.areaT1 ~ log.ros.area + (1|plot) + (1|year), data = primula, REML = F)
growth2 <- lmer(log.ros.areaT1 ~ log.ros.area + trt + (1|plot) + (1|year), data = primula, REML = F)
#growth3 <- lmer(log.ros.areaT1 ~ log.ros.area*trt + (1|plot) + (1|year), data = primula, REML = F)

#noflower1<- glmer(flow.sumT1 ~ log.ros.area + (1|plot) + (1|year), data = subset(primula, flow.sumT1 > 0), family = "poisson")
noflower2<- glmer(flow.sumT1 ~ log.ros.area + trt + (1|plot) + (1|year), data = subset(primula, flow.sumT1 > 0), family = "poisson")
#noflower3<- glmer(flow.sumT1 ~ log.ros.area*trt+(1|plot) + (1|year), data = subset(primula, flow.sumT1 > 0), family = "poisson")


seed3  <- glmer(total.seeds~log.ros.area*trt + (1|year)+ (1|plot), data = subset(primula, total.seeds >0), family = "poisson")


growth_var <- as.data.frame(VarCorr(growth2)) #assumes same variance across all, not sure if thats ok


```

```{r}

#prob.flower.makes.seeds <- 0.73 #this is a made up number
## I need to change this because this is treatment dependent!
#no.seeds <- 36 #if you make seeds, this is on average how many seeds you make. But, this needs to be a function below
prob.seed.germ <- .001 #made up, will change later (after seed addition data comes in )
prob.seedling.to.1leaf <- .1
prob.1leaf.to.1leaf <- .1
prob.1leaf.to.2leaf <- .1

#eventually this might change if we want treatment specific size of new recruits - will look into it more
new_sd <- sd(new.plants$log.ros.area)
new_mean <- mean(new.plants$log.ros.area)

```

Define the min and max size, which are the integration bounds of the IPM.
```{r size bounds, echo=T}
minRealsize <- min(primula$log.ros.area, na.rm=T) 

maxRealsize <- 1.1* max(primula$log.ros.area,na.rm=T)

#now add a new min & max size to keep the plants in for eviction
#note - this was code from Townsenia code - will need to revisit for Primula!
min.size <-minRealsize-1 #lower
max.size <-maxRealsize+1.5 #upper
```

```{r parameter vector, echo=FALSE}

# pflower

# av.grow.max.temp <- climate_percentiles$maxT_mean[1]
# av.grow.min.temp <- climate_percentiles$minT_mean[1]
#rows <- expand.grid(precip= c(mean(climate$grow.season.tot.precip), min(climate$grow.season.tot.precip), max(climate$grow.season.tot.precip)), temp = c(mean(climate$grow.season.mean.mean.temp), min(climate$grow.season.mean.mean.temp), max(climate$grow.season.mean.mean.temp)), reproduction = c("veg","flowered"))
#rows <- expand.grid(precip= seq(min(climate$grow.season.tot.precip), max(climate$grow.season.tot.precip), by = 25), temp = seq(min(climate$grow.season.mean.mean.temp), max(climate$grow.season.mean.mean.temp), by = .75), reproduction = c("veg","flowered"))
rows <- expand.grid(trt = c("control", "drought", "irrigated"))

#rows <- rows %>% mutate(temp = round(temp, 2))

params=data.frame(
	growth.int = c(NA),
	#growth.int.control = c(NA,NA, NA, NA, NA, NA),
	#growth.int.irr = NA,
	#growth.int.drought = NA,
	growth.slope  = NA,
	#growth.slope.irr = NA,
	#growth.slope.drought = NA,
	growth.sd=NA,
	
	surv.int=NA,
	surv.slope=NA,
	
	pflow.int = NA,
	#pflow.int.flowered=NA,
	#pflow.int.veg=NA,
	pflow.slope = NA,
	#pflow.slope.flowered=NA,
	#pflow.slope.veg=NA,
	
	no.flow.int=NA,
	no.flow.slope=NA,
	no.seeds.int=NA,
	no.seeds.slope=NA,
	
	recruit.size.mean=NA,
	recruit.size.sd=NA,
	
	#p.flower.makes.seed=NA,
	#no.seeds = NA,
	prob.seed.germ = NA
	#pdorm.int=NA
)
params <- bind_cols(params, rows)

#growth
params$growth.int[params$trt == "control"] <- fixef(growth2)[1]
params$growth.int[params$trt == "irrigated"] <- fixef(growth2)[1] + fixef(growth2)[4]
params$growth.int[params$trt == "drought"] <- fixef(growth2)[1] + fixef(growth2)[3]

params$growth.slope <- fixef(growth2)[2]

#survival
params$surv.int <- fixef(surv1)[1]

params$surv.slope <- fixef(surv1)[2] # survival size t

#pflower
params$pflow.int[params$trt == "control"] <- fixef(pflower2)[1]
params$pflow.int[params$trt == "irrigated"] <- fixef(pflower2)[1] + fixef(pflower2)[4]
params$pflow.int[params$trt == "drought"] <- fixef(pflower2)[1] + fixef(pflower2)[3]

params$pflow.slope <- fixef(pflower2)[2]

#no.flowers
params$no.flow.int[params$trt == "control"] <- fixef(noflower2)[1]
params$no.flow.int[params$trt == "irrigated"] <- fixef(noflower2)[1] + fixef(noflower2)[4]
params$no.flow.int[params$trt == "drought"] <- fixef(noflower2)[1] + fixef(noflower2)[3]

params$no.flow.slope <- fixef(noflower2)[2] # flower number production size t

#no.seeds
params$no.seeds.int[params$trt == "control"] <- fixef(seed3)[1]
params$no.seeds.slope[params$trt == "control"] <- fixef(seed3)[2]

params$no.seeds.int[params$trt == "drought"] <- fixef(seed3)[1] + fixef(seed3)[4]
params$no.seeds.slope[params$trt == "drought"] <- fixef(seed3)[2] + fixef(seed3)[6]

params$no.seeds.int[params$trt == "irrigated"] <- fixef(seed3)[1] + fixef(seed3)[3]
params$no.seeds.slope[params$trt == "irrigated"] <- fixef(seed3)[2] + fixef(seed3)[5]


#params$no.seeds <- no.seeds
params$prob.seed.germ <- prob.seed.germ
params$recruit.size.mean <- new_mean # mean new >1 leaf plant size
params$recruit.size.sd<- new_sd # sd of new >1 leaf plant size
params$growth.sd <- growth_var[growth_var$grp=="Residual","sdcor"] # growth sd of residuals


```

```{r VR functions}
###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
###         Load functions
###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#SURVIVAL AT SIZE X
s.x=function(x,params) {
	u=exp(params$surv.int+params$surv.slope*x)
	return(u/(1+u))
    }

#GROWTH FROM SIZE X TO Y; just using one function! No need to seperate it out for each trt. Later on different params will be fed into this
g.yx<-function(y,x,params){
    #ignoring eviction here...
  #xb=pmin(pmax(x,minRealsize),maxRealsize) #Transforms all values below/above limits in min/max size (floor & ceiling)
  #growth_to_newsize <-params$growth.int.irr + params$growth.slope*xb
  #growth_sd <- params$growth.sd
  #return(dnorm(y,mean=growth_to_newsize,sd=growth_sd))
  dnorm(y,mean=params$growth.int + params$growth.slope*x,sd=params$growth.sd)

}

#Tom Miller's combined s and g kernel
P <- function(y, x, params){
  s.x(x, params)*g.yx(y, x, params)
}

#PROBABILITY OF FLOWERING OF SIZE X individuals that did not flower:
pf.x <-function(x,params){
	u<-exp(params$pflow.int+params$pflow.slope*x)
	return(u/(1+u))
}


# #PRODUCTION OF seedlings by X-SIZED plants that flowered the previous year
###Here i've put in the misc bits, but not sure if this is correct - seems ok for now

f.yx=function(x,params) { 		
	return(pf.x(x,params)*exp(params$no.flow.int+params$no.flow.slope*x)* exp(params$no.seeds.int+params$no.seeds.slope*x) *
    params$prob.seed.germ)
}

#SIZE DISTRIBUTION OF RECRUITS - separate function (before was part of f.yx). Now it feeds into a stage so won't be feeding back into the kernel

recruit.size<-function(y,params){
    ## returns a *probability density distribution*
  dnorm(y,mean=params$recruit.size.mean,sd=params$recruit.size.sd)
}
```

```{r setting up stage matrices}
params_list <-  filter(params) %>% split(., seq(nrow(.))) #this splits up params into X rows, which I can feed into the function below

#params_in <- params_list[1] #to test it!
# BIGMATRIX ---------------------------------------------------------------
#building off of code from Tom Miller:
mat.size = 100 #dimensions of continuous matrix
bigmatrix<-function(params_list, mat.size)
  {
  n<-mat.size
  L<-min.size
  U<-max.size
  #these are the upper and lower integration limits
  h<-(U-L)/n                   #Bin size
  b<-L+c(0:n)*h;               #Lower boundaries of bins 
  y<-0.5*(b[1:n]+b[2:(n+1)]);  #Bins' midpoints
  #these are the boundary points (b) and mesh points (y)

  # Fertility matrix
  Fmat<-matrix(0,(n+2),(n+2))
  
  # top row: # seedlings produced by each size class:
  Fmat[1,3:(n+2)]<-f.yx(y,params_list) #This is a y because it is the fecundity kernel for plants that have already grown/survived, I think? It's what Tom has
  
  # Growth/survival transition matrix
  Tmat<-matrix(0,(n+2),(n+2))
  
  # probability seedling becomes a 1 leaf plant
  Tmat[2,1]<- prob.seedling.to.1leaf
  
   # probability 1 leaf plant stays as a 1 leaf plant
  Tmat[2,2]<- prob.1leaf.to.1leaf
  
  # Graduation from 1 leaf to cts size = prob 1 leaf becomes a 2 leaf * size dist of new 2 leafers
  Tmat[3:(n+2),2]<- prob.1leaf.to.2leaf *recruit.size(y,params_list) * h
  
  # Growth/survival transitions among cts sizes
  Tmat[3:(n+2),3:(n+2)]<- t(outer(y,y,P,params=params_list)) * h 
  
  # Put it all together
  IPMmat<-Fmat+Tmat     #Full Kernel is simply a summation of fertility and transition matrix
  out_matrix <- list(IPMmat=IPMmat,Fmat=Fmat,Tmat=Tmat,meshpts=y)
  
  out_lamb <- data.frame(lambda = lambda(IPMmat), trt = params_list$trt)
  #return(out_matrix) #can check this to have a list of all of the matrices listed above
  return(out_lamb) #for now, I just want lambdas

}

#what I want returned is x lambdas
lamb_lists <- lapply(X = params_list, FUN = bigmatrix, mat.size = mat.size) #for each row of params_list, run the big matrix function!
#great~! now make it a df
primula_lambda <- do.call(rbind, lamb_lists)
#write.csv(primula_lambda, "../tables/primula.climate.lambdas.csv", row.names = F)


#code from meeting with Sarah that worked on the townsenia problem! Above I came up with a better solution for the primula data
#model_out <- params_list %>% map(., .f = bigmatrix, params = params_list,
#                            mat.size = mat.size) %>% bind_rows()


#this is code that works for just one set of params
# primula_lambda <- bigmatrix(params = params_in,
#                             mat.size = mat.size)
# lambda(primula_lambda$IPMmat)

# image(primula_lambda$IPMmat,main='full kernel - control flowered')	
# image(primula_lambda$Fmat,main='F kernel - control flowered')	
# image(primula_lambda$Tmat,main='S+G kernel - control flowered')	
# abline(0,1,lwd=3)	


#definitely individuals are being evicted. who is the dark square on bottom left? Oh right it is the stage transitions
## And I'm not sure that the F kernel - axis should be flipped, anyway
```

